![img](http://liufan.vip/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2019-4-5-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F/1.png)



# 直接插入排序（Insertion Sort）

### 基本思想

将待排序的无序数列看成是一个仅含有**一个元素的有序数列和一个无序数列**，将无序数列中的元素逐次插入到有序数列中，从而获得最终的有序数列。

### 算法流程

1. 初始时，a[0]自成一个有序区，无序区为a[1,...,n-1]，令i=1
2. 将 a[i]并入当前的有序区a[0,...,i-1]
3. i++并重复步骤2，直到i=n-1，排序完成

**详细描述如下：**

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置中
6. 重复步骤2

```c
//直接插入法一
void InsertSort1(int a[], int n)
{
    int i, j;
    for(i=1; i<n; i++)
        if(a[i] < a[i-1])   
        {
            int temp = a[i];                     //保存要比较的值
            for(j=i-1; j>=0 && a[j]>temp; j--)   //从后向前查找待插入位置
                a[j+1] = a[j];                   //交换位置
            a[j+1] = temp;                       //复制到插入位置
        }
}

//直接插入法二：用数据交换代替法一的数据后移(比较对象只考虑两个元素)
void InsertSort2(int a[], int n)
{
    for(int i=1; i<n; i++)
        for(int j=i-1; j>=0 && a[j]>a[j+1]; j--)
            Swap(a[j], a[j+1]);
}

void Swap(int a,int b)
{
    int temp;
    temp=a;
    a=b;
    b=temp;
}
```

# 快速排序

```c
//快速排序
void QuickSort(int a[],int left,int right)
{
    if(left<right)
    {
        int i=left,j=right；
        int base=a[left];             //基准
        while(i<j)
        {
            while(i<j&&a[j]>=base)    //从右往左找小于base的元素
                j--;
            if(i<j)
                a[i++]=a[j];
            while(i<j&&a[i]<base)    //从左往右找大于base的值
                i++;
            if(i<j)
                a[j--]=a[i];
        }
        a[i]=base;                  //将基准base填入最后的坑中
        QuickSort(a,left,i-1);      //递归调用，分治
        QuickSort(a,i+1,right);
    }
}
```

# 鸡尾酒排序

```c
//鸡尾酒排序
void CocktailSort(int a[], int n){
    int left = 0, right=n-1;
    while(left<right){
        for(int i=left;i<right-1;i++){       //从前往后排
            if(a[i]>a[i+1]){
                Swap(a[i],a[i+1]);
            }           
            right-=1;
            for(int j=right;j>left;j--){     //从后往前排
                if(a[j]<a[j-1]){
                    Swap(a[j],a[j-1]);
                }
            }
            left+=1;
        }
    }    
}
```

# 冒泡排序

遍历数组，找到比选中数更大/小的数，交换两者位置

```c
//冒泡排序
void BubbleSort(int* a,int N)
{
    for(int i=0;i<N;i++)
    {
    	for(int j=1;j<N-i;j++)
        { 
            if(a[j]<a[j-1])
            {
               	Swap(a[j-1],a[j]);//交换两者位置
            }
        }
    }
}
```

# 希尔排序

```c

//希尔排序法一
void shellSort1(int a[],int n){
    int i,j,gap,temp;
    for(gap = n/2;gap>0;gap/=2){
        for(i=gap;i<n;i+=gap){
            temp = a[i];
            for(j = i-gap;j>=0&&a[j]>temp;j-=gap){
                a[j+gap] = a[j];
            }
            a[j+gap] = temp;
        }
    }
}
//希尔排序法二，和上面的直接插入排序类似，用数据交换代替法一的数据后移(比较对象只考虑两个元素)
void ShellSort2(int a[], int n)
{
    int i, j, gap;
    //分组
    for(gap=n/2; gap>0; gap/=2)
        //直接插入排序
        for(i=gap; i<n; i++)
            for(j=i-gap; j>=0 && a[j]>a[j+gap]; j-=gap)
                Swap(a[j], a[j+gap]);
}
```



# 折半插入排序

```c
void ZhebanInsertSort(int a[],int n){
    int i,j,low,high,mid;
    for(i=1;i<n;i++){
        temp=a[i];
        low=1,high=i;            //设置折半查找范围
        while(low<=high){
            mid=(low+high)/2;  
            if(a[mid]>temp) 
                high=mid-1;        //查找左半部分
            else
                low=mid+1;        //查找右半部分
        }
        for(j=i;j>=high+1;--j)
            a[j+1]=a[j];          //统一后移元素，空出插入位置
        a[high+1]=temp;           //插入
    }
}
```

