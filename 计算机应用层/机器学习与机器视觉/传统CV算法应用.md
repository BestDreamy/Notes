# 图像处理算法的典型应用

本博客参考《OpenCV3编程入门》（*毛星云* 冷雪飞 电子工业出版社）写成（还有来自毛星云dalao在csdn写成的系列博文），本篇内容旨在总结*嵌入式设备*中常用（基础）的机器视觉算法（上面书籍的后四章），代码主要使用OpenCV实现，部分代码可以直接在OpenMV或类似的嵌入式平台上部署

> 悼念浅默大佬，感谢他为我们带来的技术博客和教程

## 直方图及其应用

**直方图**（**Histogram**）是对数据进行统计的一种方法，通过一个二维的统计图表，其横坐标是统计样本，纵坐标是样本对应某个属性的度量。图像处理中，使用**图像直方图**表示数字图像中像素数据分布统计。下面将以灰度和RGB直方图作为引入，但是任何能够有效描述图像的特征数据都能作为直方图的统计量。

### 灰度和RGB直方图

假设有一副5*5像素的灰度图像，其像素分布如下：

> 1,2,3,2,1,
>
> 3,4,5,2,4,
>
> 5,6,1,5,2,
>
> 1,3,4,6,5,
>
> 8,5,9,1,4
>
> 这里作为举例只列举了个位数值，实际图像的像素值可能是0~255的任何数

我们将图像像素的灰度值作为横坐标，将每个灰度值对应的像素个数作为纵坐标，就能得到一副直方图

0：0个像素；1：5个像素；2：4个像素；3：3个像素；4：4个像素；5：5个像素；6：2个像素；7：0个像素；8：1个像素；9：1个像素；......；254：0个像素；255：0个像素

我们把它画成一幅图：

![image-20220626153656191](传统CV算法应用.assets/image-20220626153656191.png)

使用下面的代码生成（基于matplotlib数学库而不是opencv）

```python
import matplotlib.pyplot as plt

data = [
    1, 2, 3, 2, 1, 3, 4, 5, 2, 4, 5, 6, 1, 5, 2, 1, 3, 4, 6, 5, 8, 5, 9, 1, 4
]

plt.hist(data, bins=256, range=(0, 255), density=False)
# bins:直方图条数
# range:直方图横坐标范围
# density:当值为False时绘制频数直方图,否则绘制频率直方图
plt.show()
```

也就不难理解直方图的含义：按照灰度值（0~255的int8范围）依次统计图像中对应值像素的数量

我们在图像直方图中定义下面这些概念：

* **bin/bins**：直方图的组距，其数值是从数据中计算出的特征统计量。这也就是直观意义上的直方图横坐标
* **range**：每个特征空间的取值范围。也就是直观意义上直方图横坐标值的集合（“定义域”）
* **dims**：需要统计特征的数目。在灰度图像直方图中，dims=1；在rgb图像直方图中，dims=3。这就是直观意义上直方图统计过程中要考虑的特征元素数目

再给出一个RGB直方图的例子：

![image-20220626160003972](传统CV算法应用.assets/image-20220626160003972.png)

使用OpenMV（给没做过硬件的老哥科普下这是一个可编程的摄像头，基于stm32（微控制器，ARM Cortex-M内核）开发，内置了很多机器视觉算法，官方开发了一套IDE方便进行机器视觉相关应用的开发）就可以在IDE里面采集到这样的图像，下面的直方图就是RGB直方图了。和灰度直方图类似，它分别统计了R、G、B三种颜色像素值在图像中的数目，也就是所谓的三个**通道**。

我们这就可以知道如果需要用直方图法获取图像信息，只需要把图像相关元素数据值作为横坐标，然后统计图像每个与之相关像素的数目，将其作为对应纵坐标，就可以绘制直方图了。不仅仅是RGB颜色，HSV颜色、YCbCr颜色，甚至梯度、方向等信息都可以作为横坐标

### 直方图计算

OpenCV中提供了计算和绘制直方图的函数，如下所示：

```c++
void cv::calcHist(const cv::Mat *images, 
                  int nimages, //输入图像的个数
                  const int *channels, //dims的索引
                  cv::InputArray mask,
                  cv::OutputArray hist, //输出一个二维的直方图
                  int dims, //需要统计的dims数量，或者说需要直方图的通道数
                  const int *histSize, //存放每个维度直方图尺寸的数组
                  const float **ranges, //直方图横坐标范围
                  bool uniform = true, //默认直方图均匀
                  bool accumulate = false //默认直方图在配置阶段清零
                 )
```

需要注意：这里输入的image要求具有相同的深度（CV_8U或CV_32F）和相同的尺寸

如果mask非空，那么它必须是8位且和images具有相同尺寸，这个参数用于标记统计直方图的数组元素数据

dims参数不能大于CV_MAX_DIMS（OpenCV3中设置为32）

OpenCV还提供了一些用于处理直方图的函数

* 寻找最小值和最大值

    下面的函数从输入数组src中找出其中的最小值（最小值位置）和最大值（最大值位置）的指针，兼容一维的数组和二维的图像数据

    ```c++
    void cv::minMaxLoc(cv::InputArray src, 
                       double *minVal, 
                       double *maxVal = (double *)0, 
                       cv::Point *minLoc = (cv::Point *)0, 
                       cv::Point *maxLoc = (cv::Point *)0, 
                       cv::InputArray mask = noArray()
                      )
    ```

* 比较直方图

    下面的函数可以通过相关性、卡方统计量、直方图香蕉、Bhattacharyya距离四种方法对两个直方图进行比较

    ```c++
    double cv::compareHist(cv::InputArray H1, //直方图1
                           cv::InputArray H2, //直方图2
                           int method) //比较算法
    ```

    method参数可以选择

    * CV_COMP_CORREL：相关统计
    * CV_COMP_CHISQR：卡方
    * CV_COMP_INTERSECT：相交
    * CV_COMP_BHATTACHARYYA：Bhattacharyya距离，也可以使用CV_COMP_HELLINGER参数‘

    函数会输出匹配度

### 直方图均衡

有些情况下，图片的对比度很低，呈现雾蒙蒙的状态，如下所示（下面先讨论灰度图像，也就是颜色数据通道为1的情况）：

![image-20220626150430229](传统CV算法应用.assets/image-20220626150430229.png)

我们通过一些方法提高它的对比度，就能得到更清晰的图像（锐化图像）：

> **对比度**是画面黑与白的比值，也就是从黑到白的渐变层次。比值越大，从黑到白的渐变层次就越多，色彩表现就越丰富

![image-20220626150509638](传统CV算法应用.assets/image-20220626150509638.png)

还有些情况下，图片呈现很亮或者很暗的状态，如下图所示：

![image-20220626150914016](传统CV算法应用.assets/image-20220626150914016.png)

此时也可以通过一种算法提高其亮度：

![image-20220626151028946](传统CV算法应用.assets/image-20220626151028946.png)

以上两种情况都可以使用**直方图均衡化**算法来实现，同时该算法还能用在图像去雾等领域

这两种情况都有一个共性：图像的直方图集中在了同一个区域。未经均衡化的图像往往都具有这样的特性：直方图集中在某个范围，就比如上面的示例，所有像素值都集中在了0~10区间

![image-20220626153656191](传统CV算法应用.assets/image-20220626153656191.png)

直方图均衡化的主要思想是**把原始图像的直方图从比较集中的某个区间变成在全部范围内“均匀”的分布**。通过对图像进行非线性拉伸，重新分配图像像素值，就能让一定范围内的像素数量大致相同

如果一副图像的像素占有很多的灰度级而且分布均匀，那么这样的图像往往有高对比度和多变的灰度色调；对于RGB图像也是类似的，均匀分布的RGB值往往具有更高的对比度，同时图像明暗处的亮度也偏向平均，因此直方图均衡化对于背景和前景都太亮或者太暗的图像非常有用

作为传统的图像增强算法，直方图均衡化的一个主要优势是它是一个相当直观的技术并且是可逆操作，如果已知均衡化函数，那么就可以恢复原始的直方图，并且计算量也不大；缺点则是它对处理的数据不加选择，可能会增加背景杂讯的对比度并且降低有用信号的对比度；变换后图像的灰度级/色度减少，某些细节消失；在直方图有尖锐高峰情况下，经处理后会出现对比度不自然的过分增强。

直方图均衡化的目标就是仅靠输入图像直方图信息自动达到增强图像效果，一般的实现思路是*对图像中像素个数多的值进行展宽，对图像中像素个数少的值进行压缩*

需要注意：**已经进行均衡化的图片再次均衡化将不会有任何变化**

OpenCV中提供了equalizeHist()函数来执行直方图均衡化

```c++
void cv::equalizeHist(cv::InputArray src, //输入图像
                      cv::OutputArray dst //输出均衡化后的图像
                     )
```

内部采用如下算法：

1. 计算输入的直方图

2. 进行直方图归一化，将直方图组距和设置为255

3. 计算直方图积分
    $$
    H'(i)=\sum_{0\le j \le i} H(j)
    $$

4. 以H'作为查询表进行图像变换
    $$
    dst(x,y)=H' (src(x,y))
    $$

### 模板匹配





















## 轮廓检测与应用

图像中的一个轮廓就是一系列点的集合，或者说图像中的一条曲线

OpenCV中提供了一些基于梯度的轮廓处理函数

### 寻找轮廓









### 寻找凸包

**凸包**（Convex Hull）：对于给定二维平面上的点集，凸包是将最外层的点连接起来构成的凸多边形。

利用凸包计算其凸缺陷从而获取物体轮廓是一种经典的算法，OpenCV提供了convexHull()函数来寻找图像点集中的凸包

```c++
void cv::convexHull(cv::InputArray points, 
                    cv::OutputArray hull, 
                    bool clockwise = false, //当为true时，输出顺时针方向的凸包；否则输出逆时针
                    bool returnPoints = true //当为true时返回凸包的各个点，否则返回各点的指数
                   )
```







### 图像轮廓矩







### 分水岭算法















## 特征检测

OpenCV中的特征检测、角点检测等算法由xfeature2d库提供，这是一个第三方库，需要额外配置才能使用。如果需要成熟的算法实现，应使用OpenCV2中的feature2d组件

## 综合应用示例

下面来介绍几个经典的传统机器视觉算法（基于OpenCV-python）应用

### 颜色识别







### 车牌识别







### 小车巡线







### 距离检测









# 参考资料

https://zhuanlan.zhihu.com/p/114185254

https://blog.csdn.net/qq_15971883/article/details/88699218
