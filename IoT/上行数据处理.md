# 处理IoT上传数据

## LwIP

LwIP即Light Weight IP协议，可以在无操作系统或在RTOS的情况下运行，资源占用仅达几十KB RAM、40KB ROM，适合在嵌入式设备中运行，现在一般的物联网设备都在使用LwIP协议，它的基本功能如下：

* 支持多网口IP转发
* 支持ICMP、DHCP
* 支持扩展UDP
* 支持阻塞控制、RTT估算和快速转发的TCP
* 提供回调接口（RAW API）
* 支持可选的Berkeley接口API

LwIP的实现非常复杂，但目前代码开源且可以较方便地在各种设备中移植，很多设备厂商也都提供了LwIP的模板和库，所以这里主要介绍LwIP的驱动编写和应用

一个LwIP设备通常需要以下层次结构支持：

* 物理层

  包括PHY芯片、实现网络连接的接口与基础电路

* 数据链路层

  * MAC层：硬件设备的以太网控制器
  * 驱动层：以太网设备驱动

* 网络IP层与传输层

  主要由LwIP核心代码构成

  LwIP会自行基于硬件API构建TCP/IP协议API，并实现通用的应用程序API

* 应用层

  网络应用程序

### LwIP的基本API

LwIP提供三种API

* **RAW API**：无需操作系统就能使用的API，该接口把协议栈和应用程序放在同一个进程，使用状态机和回调函数进行控制，使用这一接口的应用程序无需连续操作

  类似ESP32和STM32这样的SoC利用内置/外置网卡驱动（WiFi基带）就可以基于RAW API实现网络通信

* **NETCONN API**：需要操作系统支持，将接收和处理放在同一线程的API，效率略低于RAW API，但软件兼容性更好一些

* **BSD API**：基于UNIX的POSIX和“万物皆文件”思想的标准AP，方便应用程序移植，但是因为在嵌入式系统中效率较低且占用资源较多而较少使用。现在的RT-Thread能够提供兼容该API的软件移植包，但是需要跑在STM32H750这样的中高性能嵌入式设备上才能实现流畅运行

### RAW API

该API的最大特点就是效率高但编程难度高，需要开发者熟悉函数回调机制

它的最基本单位是PCB（协议控制块，Protocol Control Block，注意不是Print Circuit Board！），在功能上类似socket

根据传输协议，PCB分为TCP PCB和UDP PCB两种

它的对应API如下所示

```c
//创建一个新的TCP PCB
struct tcp_pcb* tcp_new(void)
{
    return tcp_alloc(TCP_PRIO_NORMAL);
}

//绑定PCB到本地端口号和IP地址
err_t tcp_bind(struct tcp_pcb * pcb, struct ip_addr * ipaddr, u16_t port);
//使用IP_ADDR_ANY可以将PCB绑定到任何本地地址    

//监听PCB
#define tcp_listen(pcb) tcp_listen_with_backlog(pcb,TCP_DEFAULT_LISTEN_BACKLOG)
struct tcp_pcb * tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog);
//该函数会返回一个新的已处于监听状态的TCP PCB，原始的PCB则会被释放
//所以一定要像tcpb=tcp_listen(tcpb);这样使用这个函数

//连接服务器
err_t tcp_connect(struct tcp_pcb * pcb, struct ip_addr * ipaddr, u16_t port,
                 err_t (* connected)(void* arg, struct tcp_pcb * tpcb, err_t err));
/*
struct tcp_pcb * pcb表示需要设置的TCP PCB
struct ip_addr * ipaddr表示服务器的IP地址，可以使用以下方法设置IP：
	1. 定义一个struct ip_addr * ipaddr结构体
	2. 使用IP4_ADDR(&ipaddr,a,b,c,d)设置IP，其中a、b、c、d是IPv4地址的中间几个数字
	比如192.168.1.2对应的就是a=192,b=168,c=1,d=2
u16_t port表示服务器端口号
err_t (* connected)(void* arg, struct tcp_pcb * tpcb, err_t err)表示连接成功时的回调函数，开发者应该在其中使用状态机来实现对连接状态的控制
*/

//设置有连接请求时的回调函数
void tcp_accept(struct tcp_pcb * pcb,
               err_t (* accept)(void* arg, struct tcp_pcb * newpcb, err_t err))
{
    pcb->accept = accept;
}
/* 其中的accept就表示回调函数，回调函数应该像下面这样 */
static err_t tcp_server_accept_handler(void* arg, struct tcp_pcb * newpcb, err_t err)
{
    //设置回调函数优先级，当存在多个连接时非常重要，该函数必须被调用
    tcp_setprio(pcb, TCP_PRIO_MIN);
    //设置TCP数据接收回调函数，当有网络数据时，tcp_server_recv会被调用
    tcp_recv(pcb,tcp_server_recv);
    err = ERR_OK; //这里是函数的执行结果，一般采用if语句判断上述函数是否成功执行
    return err;
}
//其中tcp_recv用于设置TCP数据接收回调函数
void tcp_recv(struct tcp_pcb * pcb,
             err_t (* recv)(void * arg, struct tcp_pcb * tpcb, struct pbuf * p, err_t err))
{
    pcb->recv = recv;
}
//回调函数多用于缓存网络数据，典型的TCP数据接收回调函数如下所示
static err_t tcp_server_recv(void * arg, struct tcp_pcb * tpcb, struct pbuf * p, err_t err)
{
    //定义一个pbuf指针，指向传入的参数p，用于接收网络数据并缓存到本地
    struct pbuf * p_temp = p;
    
    //如果数据非空
    if(p_temp != NULL)
    {
        tcp_recved(pcb, p_temp->tot_len);//读取数据
        //如果数据非空，采用遍历链表的方式遍历数据（实际上底层就是个链表）
        while(p_temp != NULL)
        {
            //把接收到的数据重新发送给客户端
            tcp_write(pcb, p_temp->payload, p_temp->len, TCP_WRITE_FLAG_COPY);
            //启动发送
            tcp_output(pcb);
            //获取下一个数据包
            p_temp = p_temp->next;
		}
	}
    else //数据为空则表示接收失败
    {
        tcl_close(pcb); //关闭连接
    }
    pbuf_free(p); //释放内存
    err = ERR_OK;
    return err;
}
```

RAW API的编程思路和Socket很相似，但是其中使用回调函数而不是顺序结构来对数据流进行控制

`tcp_new`、`tcp_bind`、`tcp_listen`使用方法和socket的对应函数是基本一致的；但是`tcp_accept`需要对应设置一个`tcp_server_accept_handler`回调函数，并再通过`tcp_recv`设置`tcp_server_recv_handler`回调函数才能完成Socket中的accept和receive完成的功能，这是因为LwIP将所有任务放在同一个进程，没有操作系统通过事件集、信号量等方法在待接收和已接收FIFO中进行数据传递。











