# OpenWrt与嵌入式Linux

由于要接手学长留下来的一个项目，“被迫”要学习OpenWrt的配置方法——虽然对于一个five电工来说这事挺莫名其妙的，但还是硬着头皮上吧（我本想拒绝，但他给的是在太多了）

### 简介

在[官网](https://openwrt.org/)中这样描述OpenWrt

> OpenWrt项目是一个针对嵌入式设备的Linux操作系统。OpenWrt不是一个单一且不可更改的固件，而是提供了具有软件包管理功能的完全可写的文件系统。这使您可以从供应商提供的应用范围和配置中解脱出来，并且让您通过使用适配任何应用的软件包来定制设备。对于开发人员来说，OpenWrt是一个无需围绕它构建完整固件就能开发应用程序的框架; 对于普通用户来说，这意味着拥有了完全定制的能力，能以意想不到的方式使用该设备。

听上去很高大上，实际上OpenWrt就和Ubuntu、CentOS、Raspbian等*GNU/Linux发行版*一样，是一个基于Linux内核的操作系统。只不过它具有**高度模块化可定制**的特点，并且自带一系列**网络组件**，因此常常被用于路由器、工控、智能家居、小型交换机中。笔者接手的这个项目就是基于OpenWrt实现**路由器**-交换机的应用，并配置一个**网络摄像头**和一个**网口数据转串口**

OpenWrt除了以上特点外，还有一个堪称嵌入式Linux杀手锏的特性：==超级大规模的开源社区==。可能是因为大家都很喜欢软路由，OpenWrt的软件包已经达到了好几千，这让它能秒掉一堆其他的嵌入式Linux发行版

### OpenWrt与桌面Linux操作系统

可能大家无法理解OpenWrt这种发行版的独特之处，请允许我在这里为大家重新介绍一下桌面Linux操作系统

一般的桌面操作系统都很难在低性能的嵌入式设备上运行，这是因为两点：

1. 它们需要占用大量的系统资源，尤其是内存用于支持各种deamon的运行

    一般的GNU/Linux发行版都采用Bash乃至更人性化也更占用资源的Zshell作为终端；而OpenWrt为了适应低性能的处理器，采用更简单的**Ash**作为默认shell。此外，OpenWrt使用的C库是**uClibc**而不是glibc，这是一个面向嵌入式系统的小型C标准库，也有很多RTOS比如FreeRTOS和RT-Thread都采用了这个C库

2. 它们的体积都比较大，一个典型的桌面操作系统占用的存储空间至少在1GB以上

    Ubuntu已经膨胀到了2GB，Debian也往往需要占据1GB的硬盘/SD卡/Flash空间；但OpenWrt具有很强的可裁减性，其内核、驱动、自带软件都可以方便地通过menuconfig进行配置，它的运行内存最小只要32M，存放代码数据的Flash空间最小只要8M，但支持使用完备的Linux内核，支持无线、有线网络应用

**OpenWrt牺牲了兼容性**，但是由于庞大的开源社区资源，他能够**对大多数网络嵌入式设备提供支持**

**OpenWrt优化了效率和资源占用**，然而因为难以支持更高性能开销的应用导致**其工作范围局限在嵌入式领域**

### OpenWrt与一般的嵌入式Linux

一般的嵌入式Linux都具有上面所说的特点，一些介于桌面Linux操作系统和嵌入式Linux操作系统之间并经过特殊优化的操作系统如Raspbian甚至能够提供更高的性能-资源占用比，但是OpenWrt相比一般的嵌入式Linux系统具有强大的多的网络应用：

* 默认自带SSH

* 可选的图形化网络操作界面Luci（Lua Configuration Interface）

    这是一个使用Lua脚本语言编写的mvc架构的web框架，包含了openwrt的配置界面和一套扩展API。安装luci-core后只要在浏览器中输入OpenWrt设备的IP地址，即可出现其登录界面，可以通过安装luci扩展app实现对OpenWrt设备方方面面的管理

    这个操作界面是对OpenWrt没有图形界面的有效弥补，也是它不同于其他嵌入式Linux的特殊点，这也**使OpenWrt相当好上手**

* 自带软路由模块和交换机模块，可配合硬件实现软/硬件路由功能

* 可选搭建VPN

* 可运行轻量级服务器软件

* 可运行轻量级流量整形与捕获分析软件

    OpenWrt常常被用于搭建软路由，很大程度上就是因为**它支持各种控制网络流量和数据包的应用扩展**

除了以上网络特性，OpenWrt还支持嵌入式Linux所具有的基本能力，包括对POSIX的兼容和VFS等

### OpenWrt与LEDE

LEDE是一个源于OpenWrt的分支嵌入式Linux系统，最初一批OpenWrt开发者觉得OpenWrt规则太老套，于是fork了OpenWrt的源码，然后创建了LEDE的分支，在里面添加了很多新开发流程和新功能，然后越来越多OpenWrt开发者转移到LEDE，最后二者又在2018年合并，形成了现在的OpenWrt

有的时候OpenWrt源里面会注明LEDE package，其实和OpenWrt一样，把它看成OpenWrt的某个版本即可

官网这样[解释](https://openwrt.org/zh/about)：

> OpenWrt/LEDE是一个为嵌入式设备（通常是无线路由器）开发的高扩展度的GNU/Linux发行版。与许多其他路由器的发行版不同，OpenWrt是一个完全为嵌入式设备构建的功能全面、易于修改的由现代Linux内核驱动的操作系统。在实践中，这意味着您可以得到您需要的所有功能，却仍能避免臃肿。
>
> 在2016年，LEDE项目作为OpenWrt项目的副产品而诞生，与OpenWrt共享很多相同的目标。该项目旨在成为一个嵌入式Linux版本，能让开发者、系统管理员或其他Linux爱好者轻松的为嵌入式设备特别是无线路由器构建或定制软件。*LEDE*这一名称代表*Linux Embedded Development Environment*。
>
> 项目成员与OpenWrt社区活跃成员高度重合，他们计划通过建立一个高度透明、注重协作和去中心化的社区为嵌入式Linux的开发带来新生。
>
> LEDE已公布的目标包括:
>
> - 构造一个的伟大的嵌入式Linux发行版，运行稳定且功能实用
> - 伴随社区设备测试反馈，形成定期、可预期的版本迭代
> - 通过广泛的社区参与和公开会议，建立透明的决策机制
>
> LEDE项目的形成是为解决那些被OpenWrt项目或社区认为无法解决的长远问题
>
> 1.  活跃核心开发者数量一直很低，而且无法吸引新面孔加入项目。
> 2.  不可依赖的基础设施，内部不同意和单点故障阻碍了错误修复。
> 3.  在OpenWrt项目中缺少沟通交流、透明度和协调, 无论是在核心团队内部还是在核心团队和其他团队之间。
> 4.  没有足够拥有权限的人处理补丁来流，很少关注测试和定期版本。
> 5.  不重视对稳定性和文档。
>
> 为解决这些问题，LEDE项目采用了与OpenWrt不同的组织架构：
>
> 1.  所有交流频道均是公开的，对非成员只读的频道控制在一个很好的信噪比。
> 2.  决策过程更公开，拥有投票权的开发者和重度用户数量接近50比50。
> 3.  大大简化基础设施，确保减少我们的维护工作量。
> 4.  更开明的合并政策，基于我们在处理Github上OpenWrt软件包反馈信息的经验。
> 5.  高度重视与简化发布流程合并的自动化测试。
>
> 2018年1月，OpenWrt和以前的LEDE项目同意以OpenWrt这一名称进行合并。
>
> 新的、统一的OpenWrt项目将按照 [由前LEDE项目建立的章程](https://openwrt.org/zh/rules) 进行管理。以前的LEDE和OpenWrt项目的积极成员将继续在统一的OpenWrt上工作。

## OpenWrt慢速上手

之所以这部分名叫《慢速上手》，是因为笔者要从底层开始到建立OpenWrt开发环境的全过程进行梳理，至于为什么——这就是我接手这个项目时遇到的窘境：学长跑路，给我留下了一堆残缺的资料，还有一个时灵时不灵的远程支援（虽然在前期的嵌入式开发debug部分确实给我帮了很大忙，但是怎么还在我滚挂系统的时候幸灾乐祸......这对青少年造成的坏影响，不可估量），于是只能从底层开始

所有我遇到的问题都会在

> 引用栏

中说明，避免后来者掉到坑里

### 硬件

硬件设备使用的是海凌科的MT7621模块，基于联发科7621A SoC开发

* MIPS架构CPU 1004Kc，双核主频880MHz
* 256MB内存，32MB片上Flash，16位DDR2
* 自带片上、板载晶振
* 3.3V、500mA工作电压电流
* JTAG调试接口
* 双WiFi接口
* 1个WAN口，4个LAN口，全千兆
* 2路SPI、1路IIC
* I2S、PCM等组成的音频接口
* 2路USB2.0、3.0接口
* 3路UART接口
* GPIO引出

#### GPIO





#### SPI与IIC





#### LAN口

路由器LAN口用来连接局域网，也就是内网，路由器可以**为LAN口设备提供互联网接入**或**将所有LAN口设备连接到一个VLAN实现交换机目的**

#### WAN口

路由器WAN口用于连接外网，通常会通过某个外部路由器接入互联网

WAN口是路由器的灵魂，没有WAN口的路由器就是个死交换机，有了WAN口，它才能从外网下载程序、实现路由功能等

一般路由器的配置都是单WAN口多LAN口

这里使用的路由模块配备了1WAN口4LAN口

> 很可惜，在硬件组装初期，笔者的路由器WAN口完全连不上，不仅仅无法ping通，甚至ifconfig根本看不到有这个接口
>
> 在这种情况下如果想安装软件包就必须使用LAN口，在路由器端使用SCP协议拉取上位机提供的软件包，然后用opkg进行安装（opkg是OpenWrt里面类似dpkg的一个软件包管理器，可以很方便地安装、更新、删除软件包、切换软件源）
>
> 解决方法在后文给出

#### 网络变压器与Bob-Smith电路

在网络硬件设计中经常接触到RJ-45网口，现在的RJ45网口很多都自带了网络变压器，因此只要正常接入并记得使用75欧或50欧电阻进行阻抗匹配就可以了；但是对于这里的路由模块，它使用杜邦线-排针代替RJ45网口（别问为什么，问就是特殊领域），因此需要仔细设计网络变压器部分的电路，它被称为**Bob-Smith电路**

![image-20210817004039321](OpenWrt%E4%B8%8E%E5%B5%8C%E5%85%A5%E5%BC%8FLinux.assets/image-20210817004039321.png)

他有如下几个关键作用：

1. 信号传输

    Bob-Smith电路分为**电流型**和**电压型**，根据驱动网络变压器的是电流为主还是电压为主区分

    电流型：**网络变压器输入侧**（接PHY芯片或SoC的那一侧）**需要在每个变压器抽头处上拉到电源**，如果EMC要求更加严格，还会使用一个高频（75MHz-200MHz）电感跨接在抽头和电源之间，上拉电源可以是1.8、2.5、3.3等，这是为了**增强网络变压器的驱动能力**

    同时需要在输入侧变压器正负端跨接50-100欧姆（常用75欧姆）的分流电阻，用于调整信号驱动强度

    电压型：**输入侧变压器抽头接到一起再通过100nF电容到地**，这是为了提高网络变压器的EMC性能；正负端则分别接入50-100欧分压电阻到PHY芯片或SoC，用于调整信号驱动强度

2. 阻抗匹配

    **阻抗匹配**：当传输路径上阻抗不连续时，会有反射发生，阻抗匹配的作用就是通过端接元器件时，保证传输路线上的阻抗连续以去除传输链路上产生的反射。

    网络变压器的输出端要接共模双绞线，双绞线上传输的是差分信号，因此需要使用100-150欧的阻抗匹配

    **网络变压器输出端的抽头都需要接50欧或75欧**（根据线缆长度不同决定，也可以改为100欧，但25欧因为阻值太低不常用）**到线缆，同时需要一个100nF的电容用于旁路**（滤波）

    这几个电阻就起到了阻抗匹配作用，计算公式如下
    $$
    Z=\sqrt{R-j\frac{1}{\omega C}}
    $$

3. 波形修复

    输出端的旁路电容可以有效对外传输线路上的噪声实现滤除

4. 抑制杂波

    电压型BS电路通过下拉到地的100nF滤波电容实现了滤出高频噪声的作用，而两个串联在变压器上的分压电阻配合变压器寄生电感可以提高电路对差模信号的抑制能力，从而滤除高频杂波，保证网口通信正常

    电流型BS电路则直接使用较高电流驱动的方式削弱从控制端输出的高频杂波影响。但是因为电流型电路会导致整体功耗较大，所以正在被电压型取代（不过在大功率信号传输的领域还是有一定应用）

5. 隔离高压

    这一条也可以称为**共模-差模防护**，电路可以通过一系列泻放路径抵抗从网络变压器输出端而来的浪涌电压电流。

    具体实现出于篇幅所限不在这里列出，大致思路就是*共模浪涌会被变压器和输出端电阻自行抵消，最多可能付出电容被击穿的代价，并不会伤害到控制端；而差模信号会被变压器引入到输入端，之后直接通过抽头的电容或上拉电阻被滤除，能够很大程度地减少对输入端和信号的影响*

> 在配置过程中发现：WAN口无法使用
>
> 重新刷入三次系统，反复调试一周后发现还是这样，基本上排除了所有可能的软件问题。于是决定回到硬件检查是否网络变压器或引脚出问题。首先用万用表通断档依次检测电容两端对地是否导通，发现WAN口的输入电容两端都对地为0——短路了；之后换用电阻档断电测量输入输出电阻，原本电路中使用75欧电阻，但测量中发现有两个电阻阻值不对，一个是偏小到50欧，另一个则无穷大。换掉电容电阻，上电接网线，成功秒杀

### 自定制并编译内核

[openwrt](https://github.com/openwrt/openwrt)整个项目在github上可以找到

于是直接用git下载或下载压缩包到linux系统就可以使用了

一般来说可以使用虚拟机搭建环境，但是如果你习惯了使用桌面端linux，可以直接在你的双系统/纯linux环境中搭建openwrt的开发环境

#### 配环境

根据openwrt项目中的README文档就可以简单地配好整个环境，这里摘录一下在ubuntu20中所需要安装的一些关键软件包

```shell
sudo apt install 
```

安装完依赖以后还要下载一些openwrt主分支中没有加入的源代码，这些都是诸如kernel、package之类的大号源码，需要从官方**对应的版本库**中拉取到本地

这里需要注意：版本！

在拉取之前应该确定你想要编译的内核版本

常用的大版本有14、15、16、17、18、19，小版本从.1到.9不等，各个版本差异都比较大，大版本之间软件包基本是不可能通用的，小版本之间的软件包安装也存在各种问题，所以**选版本的时候尽量考虑清楚**



> 千万注意不要被老版本的配环境资料误导，包括本篇！不要看见一个差不多的资料就从里面复制粘贴指令！
>
> 一定要选择适合自己系统的配环境资料，最好查阅官方文档！虽然会麻烦一点但是可以很大程度上避免滚挂系统！
>
> 不要问我怎么知道的，我只能说linux双系统有风险，滚挂系统重装好麻烦的！

#### menuconfig













#### 漫长的编译

make就完事了，make的时候可以换各种姿势

```shell
make V=s #输出编译信息，第一次编译一般用这个，单核编译小水管不得不品尝
make V=99 #上面这个的老版本用法

make -j12 #j后面跟你的cpu核心数，对amd cpu很友好，但是不会输出编译信息，如果要反复编译还是比较适合的，省时间
make clean #重新编译之前记得用一下，不然下次编译可能出现莫名其妙的错误
```

特别地，现在GitHub有一个叫Actions的服务，有人利用这个服务制作了一套[在线编译OpenWrt的系统](https://github.com/P3TERX/Actions-OpenWrt)

主要有以下特色：

* **免费！快速！一次编译成功率高！**
* 一键快速自动多线程编译
* 无需搭建编译环境，上手就用，用完就扔

根据[项目的中文介绍页面](https://p3terx.com/archives/build-openwrt-with-github-actions.html)里面的介绍一步步来就可以实现在线编译了（记得提前准备一个GitHub账号）

其中比较友好的是可以支持SSH连接到GitHub Actions虚拟服务器环境，直接在服务器上menuconfig

> 编译的时候出现了很多错误，不要嫌麻烦，挨个查看改正就行，第一次编译难免出错，正常情况下改一天肯定是能编译出来的
>
> 不过后续烧录能不能识别嘛......祈祷自己的设备比较常见吧；特种设备采用特殊器件装特殊系统......自求多福，运气好总能成功的

### 上位机连接到OpenWrt

终于完成了整个系统的编译，接下来就能尝试烧录并连接到设备了。烧录过程和设备具体硬件配置有关

### 烧录

如果你使用的是普通路由器，一般来说连上LAN口，登录网关地址，里面的选项里会有一个更新固件，直接把bin文件上传，点击烧录就可以了；如果使用的是一般的嵌入式设备，一般可以选择使用openocd配合jtag进行烧录，只要900+rmb氪入一套jlink基本可以完美烧录（笑）上面两个方法都太简单（没钱买设备是个人问题，有钱人烧录都很简单的）。下面介绍一下常用的三种烧录方法：

1. **uBoot烧录**

   一般来说设备出厂以后都会烧录**uBoot**，这个东西和grub有点像，但是它工作在嵌入式领域，可以支持Linux、安卓、FreeBSD等系统的引导，支持MIPS、x86、ARM、RISC-V等等各种架构的CPU，而OpenWrt对应使用的uBoot往往会着重增强网络能力，因此一般OpenWrt设备的uBoot都会自带TFTP协议的功能，并且会打开一个操作界面，因此可以直接参考厂商给出的说明，按以下步骤启动设备

   * 连接LAN口到上位机
   * 修改上位机IP为厂商指定的静态IP地址，并按照地址设定子网掩码
   * 下位机设备断电，按住Boot按键（或者叫WPS按键）（当然如果没有这个按键应该从Boot引脚到地焊接一根跳线）
   * 将设备上电
   * 保持按键一段时间，等待设备从uBoot启动（类似于按住进入键盘上某个键进入BIOS设置界面）
   * 松开按键并在上位机打开厂商指定的IP地址（浏览器打开，别想着用什么奇奇怪怪的软件）
   * 选择固件、上传、等待
   * 等到足够长时间以后（具体多长要参考厂商说明）修改LAN口为dhcp或默认设置的静态IP
   * 尝试正常连接路由器

   如果中间没有操作界面，可以尝试反复ping要连接的uBoot地址，如果能ping通那就是连上了，之后使用类似下面的uboot命令（由厂商决定）

   ```shell
   tftp 固件保存地址 要上传的固件
   erase 固件启动地址 + $固件大小
   cp 固件保存地址 固件启动地址 $固件大小
   set bootcmd 固件启动地址
   save
   boot
   ```

   总体过程就是：上传-擦除原本固件-复制上传的固件到启动位置-设置固件启动位置-保存-重启设备

   uBoot功能很强大，在某种程度上说它就像桌面版linux的livecd一样，只要uboot不刷坏，设备就可以说是不死的，一直可以通过重新进入uboot的方式刷新系统

2. **luci界面升级**

   就是上面说过的登入网关以后从配置界面上传固件升级的过程，但是一般来说会保留原来系统的配置，所以最好刷更新的固件，而不是刷老版本固件，否则会有可能变砖，还需要用第一种方法再刷一次

3. **烧录器烧录**

   如果uBoot损坏、网口有问题甚至Flash挂了，那就必须使用这种方法了。

   一般来说需要使用专门的Flash烧录器配合上位机软件对准Flash的引脚进行烧录，Flash烧录器有1.8V、3.3V、5V三种，一般来说现在的SPI Flash（最典型的W25Q128）使用3.3V烧录器就可以，但是很多设备都用上了低功耗Flash，这就需要一个电平转换板或者直接使用1.8V烧录器进行烧录。如果是最为极端的情况，Flash挂了，那就必须把Flash拆下来，换一个新Flash上去再烧录

> 在艰难的配环境过程中，某个不愿透露姓名的学长就把Flash整废了，好巧不巧那块Flash还是特殊封装的贴片元件，极其难焊接，于是只能购入巨贵的专用烧录板，烧录新的Flash以后再装上去。由于没碰见过这种情况+快递速度缓慢，流程整整走了一周。
>
> 笔者接手项目以后，还遇到了uBoot死活不启动的情况，检查电路以后发现是板上的Boot线路被莫名划坏一道，于是补好了铜线才得以启动uBoot
>
> **新手注意：遇到uBoot不启动不要慌，较大可能是你按的时间不够久或者操作有疏忽导致uBoot启动被跳过了，只要认真多试几遍总能成功，在期间善用百度很关键**

#### Luci

完成系统烧录以后，上电，上位机连上LAN口，等待几分钟，一般来说就能进入一个登陆界面，这就是OpenWrt的**Luci界面**

通过这个界面可以对设备的大多数设置进行调整，这里不多作介绍，都是很直接了当的东西

在某些角落会留着language的设置栏，在这里可以选择语言，省去啃生肉的烦恼

#### 串口终端

最传统登录Linux的方法当然是串口终端——不论嵌入式linux还是服务器linux

> TTL串口是人类的好朋友

这种方法不必多说，折腾过树莓派的人都懂，串口调试器连接UART Tx、Rx、GND，重启设备，开启Putty或者XShell，之后开机信息就会从界面喷涌而出

#### SSH

这种方法很适合具有WiFi功能的OpenWrt设备，能够省掉一根网线。不过有网线连接的时候也很实用，对于linux来说命令行总是比可视化可靠。

连上网线ping通后，直接

```shell
ssh 用户名(一般是root)@目标设备IP
```

就可以登录到OpenWrt了

#### 任何其他Linux发行版允许的登录方式

只要在内核里面使能了某个可行的登陆方式，并且硬件允许它运行，那么用户就能用这种方式进行登录OpenWrt

毕竟这可是Linux啊！

### 联网

OpenWrt一个突出特点就是自带了被称为opkg的包管理器，它和apt、yum、pacman等指令使用方式类似，能够不是太智能地只能解决软件包依赖问题：只能解决一点点。一般来说自动解决需要一层依赖的软件包安装还是可以的，但是为了安全起见还是一步一步的安装软件包吧











### 包管理器

OpenWrt最与众不同的一点就是它配备了**opkg**包管理器，常用指令如下

```shell
opkg install 
opkg remove
opkg update
opkg upgrade
```







软件包管理器的设置位于`/etc/opkg`中





并且这个包管理器也是支持**换源**的，如果某个软件园不好连接，完全可以更换当前使用的软件源，使用luci界面就可以轻松换源，如果非要使用命令行也可以像ubuntu那样直接编辑设置文件来换源

具体操作网上有很多，不再赘述



特别地，安装软件包时如果碰到了kmod字样的软件包，就说明这是一个内核驱动包，在安装它的时候很可能会遇到内核版本不正确的情况——因为自行编译的OpenWrt生成时会自动携带一个经过修改的md5码，它往往和已有的内核驱动应该对应的验证码不一致，因此会出现报错，这种情况下在安装指令后面加上如下参数就可以解决问题了

```
--force-depends
```

如果还是不行，甚至出现系统崩溃、变砖的情况，就要考虑是否是自己的软件源选错抑或是自己编译的内核版本不对了



### 换源



















snapshot版本和release版本区别

在java开发过程中，我们经常会看到代码仓库中的某些项目版本以release或snapshots结尾,现在说说这两个版本之间有什么区别.

一般来说snapshots版本代表正在开发中的版本,release代表比较稳定的发布版本.

比如我们新建一个maven项目,默认版本是这样的:

<groupId>com.example</groupId>
	<artifactId>demo</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>demo</name>
<description>Demo project</description>

    <groupId>com.example</groupId>
    	<artifactId>demo</artifactId>
    	<version>0.0.1-SNAPSHOT</version>
    	<name>demo</name>
    <description>Demo project</description>

上面0.0.1表示项目的版本号,表示这次迭代我要开发的所有主要功能都是属于这个版本的;
-SNAPSHOT表示该版本是快照版本,一般处于开发阶段,0.0.1版本还有功能没有完成,或还有bug还要修复,所以这个阶段一般代码更新比较频繁,开发人员写完代码会直接提交到代码仓库,这样之前依赖0.0.1-SNAPSHOT版本的开发人员也可以马上更新代码.
-Release表示是稳定版的,这次迭代的所有功能都已经完成,并且通过了测试之后,就可以发布为0.0.1-Release版本,Release版的一旦发布，就不要再改变代码了,所以如果之后在0.0.1-Release这个版本上发现了bug,需要修复,那么我们应该将0.0.1-Release版本改为0.0.2-SNAPSHOT,然后再修改bug并测试,没问题之后将0.0.2-SNAPSHOT改为0.0.2-Release发布.

使用maven的时候maven会根据pom文件中的version中是否带有-SNAPSHOT来判断是否是快照版本。如果是快照版本，在maven deploy时会发布到快照版本库中,依赖该版本的项目在编译打包时，maven会自动从maven仓库下载新的快照版本。如果是正式发布版本,deploy时会自动发布到正式版本库中，依赖该版本的项目在编译打包时如果本地已经存在该版本的工程默认不会从maven仓库下载新的版本.

所以如果现在开发的项目依赖了另外一个项目,如果不希望出现本来运行的好好地,过了一会儿因为依赖项目的更新突然不能运行了,那么可以选择依赖一个Release版本(如果有的话).









### 安装软件包



















