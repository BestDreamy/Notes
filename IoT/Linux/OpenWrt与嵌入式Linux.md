# OpenWrt与嵌入式Linux

由于要接手学长留下来的一个项目，“被迫”要学习OpenWrt的配置方法——虽然对于一个five电工来说这事挺莫名其妙的，但还是硬着头皮上吧（我本想拒绝，但他给的是在太多了）

### 简介

[官网]:(https://openwrt.org/)

在官网中这样描述OpenWrt

> OpenWrt项目是一个针对嵌入式设备的Linux操作系统。OpenWrt不是一个单一且不可更改的固件，而是提供了具有软件包管理功能的完全可写的文件系统。这使您可以从供应商提供的应用范围和配置中解脱出来，并且让您通过使用适配任何应用的软件包来定制设备。对于开发人员来说，OpenWrt是一个无需围绕它构建完整固件就能开发应用程序的框架; 对于普通用户来说，这意味着拥有了完全定制的能力，能以意想不到的方式使用该设备。

听上去很高大上，实际上OpenWrt就和Ubuntu、CentOS、Raspbian等*GNU/Linux发行版*一样，是一个基于Linux内核的操作系统。只不过它具有**高度模块化可定制**的特点，并且自带一系列**网络组件**，因此常常被用于路由器、工控、智能家居、小型交换机中。笔者接手的这个项目就是基于OpenWrt实现**路由器**-交换机的应用，并配置一个**网络摄像头**和一个**网口数据转串口**

OpenWrt除了以上特点外，还有一个堪称嵌入式Linux杀手锏的特性：==超级大规模的开源社区==。可能是因为大家都很喜欢软路由，OpenWrt的软件包已经达到了好几千，这让它能秒掉一堆其他的嵌入式Linux发行版

### OpenWrt与桌面Linux操作系统

可能大家无法理解OpenWrt这种发行版的独特之处，请允许我在这里为大家重新介绍一下桌面Linux操作系统

一般的桌面操作系统都很难在低性能的嵌入式设备上运行，这是因为两点：

1. 它们需要占用大量的系统资源，尤其是内存用于支持各种deamon的运行

    一般的GNU/Linux发行版都采用Bash乃至更人性化也更占用资源的Zshell作为终端；而OpenWrt为了适应低性能的处理器，采用更简单的**Ash**作为默认shell。此外，OpenWrt使用的C库是**uClibc**而不是glibc，这是一个面向嵌入式系统的小型C标准库，也有很多RTOS比如FreeRTOS和RT-Thread都采用了这个C库

2. 它们的体积都比较大，一个典型的桌面操作系统占用的存储空间至少在1GB以上

    Ubuntu已经膨胀到了2GB，Debian也往往需要占据1GB的硬盘/SD卡/Flash空间；但OpenWrt具有很强的可裁减性，其内核、驱动、自带软件都可以方便地通过menuconfig进行配置，它的运行内存最小只要32M，存放代码数据的Flash空间最小只要8M，但支持使用完备的Linux内核，支持无线、有线网络应用

**OpenWrt牺牲了兼容性**，但是由于庞大的开源社区资源，他能够**对大多数网络嵌入式设备提供支持**

**OpenWrt优化了效率和资源占用**，然而因为难以支持更高性能开销的应用导致**其工作范围局限在嵌入式领域**

### OpenWrt与一般的嵌入式Linux

一般的嵌入式Linux都具有上面所说的特点，一些介于桌面Linux操作系统和嵌入式Linux操作系统之间并经过特殊优化的操作系统如Raspbian甚至能够提供更高的性能-资源占用比，但是OpenWrt相比一般的嵌入式Linux系统具有强大的多的网络应用：

* 默认自带SSH

* 可选的图形化网络操作界面Luci（Lua Configuration Interface）

    这是一个使用Lua脚本语言编写的mvc架构的web框架，包含了openwrt的配置界面和一套扩展API。安装luci-core后只要在浏览器中输入OpenWrt设备的IP地址，即可出现其登录界面，可以通过安装luci扩展app实现对OpenWrt设备方方面面的管理

    这个操作界面是对OpenWrt没有图形界面的有效弥补，也是它不同于其他嵌入式Linux的特殊点，这也**使OpenWrt相当好上手**

* 自带软路由模块和交换机模块，可配合硬件实现软/硬件路由功能

* 可选搭建VPN

* 可运行轻量级服务器软件

* 可运行轻量级流量整形与捕获分析软件

    OpenWrt常常被用于搭建软路由，很大程度上就是因为**它支持各种控制网络流量和数据包的应用扩展**

除了以上网络特性，OpenWrt还支持嵌入式Linux所具有的基本能力，包括对POSIX的兼容和VFS等

## OpenWrt快速上手

虽然这部分名叫《快速上手》，实际上笔者要从底层开始到建立OpenWrt开发环境的全过程进行梳理，至于为什么——这就是我接手这个项目时遇到的窘境：学长跑路，给我留下了一堆残缺的资料，还有一个时灵时不灵的远程支援（虽然在前期的嵌入式开发debug部分确实给我帮了很大忙，但是怎么还在我滚挂系统的时候幸灾乐祸......这对青少年造成的坏影响，不可估量），于是只能从底层开始

所有我遇到的问题都会在

> 引用栏

中说明，避免后来者掉到坑里

### 硬件

硬件设备使用的是海凌科出品的MT7621模块，基于联发科7621A SoC开发

* MIPS架构CPU 1004Kc，双核主频880MHz
* 256MB内存，32MB片上Flash，16位DDR2
* 自带片上、板载晶振
* 3.3V、500mA工作电压电流
* JTAG调试接口
* 双WiFi接口
* 1个WAN口，4个LAN口，全千兆
* 2路SPI、1路IIC
* I2S、PCM等组成的音频接口
* 2路USB2.0、3.0接口
* 3路UART接口
* GPIO引出

#### GPIO





#### SPI与IIC





#### LAN口







#### WAN口





#### 网络变压器与Bob-Smith电路

在网络硬件设计中经常接触到RJ-45网口，现在的RJ45网口很多都自带了网络变压器，因此只要正常接入并记得使用75欧或50欧电阻进行阻抗匹配就可以了；但是对于这里的路由模块，它使用杜邦线-排针代替RJ45网口（别问为什么，问就是特殊领域），因此需要仔细设计网络变压器部分的电路，它被称为**Bob-Smith电路**

![image-20210817004039321](OpenWrt%E4%B8%8E%E5%B5%8C%E5%85%A5%E5%BC%8FLinux.assets/image-20210817004039321.png)

他有如下几个关键作用：

1. 信号传输

    Bob-Smith电路分为**电流型**和**电压型**，根据驱动网络变压器的是电流为主还是电压为主区分

    电流型：**网络变压器输入侧**（接PHY芯片或SoC的那一侧）**需要在每个变压器抽头处上拉到电源**，如果EMC要求更加严格，还会使用一个高频（75MHz-200MHz）电感跨接在抽头和电源之间，上拉电源可以是1.8、2.5、3.3等，这是为了**增强网络变压器的驱动能力**

    同时需要在输入侧变压器正负端跨接50-100欧姆（常用75欧姆）的分流电阻，用于调整信号驱动强度

    电压型：**输入侧变压器抽头接到一起再通过100nF电容到地**，这是为了提高网络变压器的EMC性能；正负端则分别接入50-100欧分压电阻到PHY芯片或SoC，用于调整信号驱动强度

2. 阻抗匹配

    网络变压器的输出端要接共模双绞线，双绞线上传输的是差分信号，因此需要使用100-150欧的阻抗匹配

    **网络变压器输出端的抽头都需要接50欧或75欧**（根据线缆长度不同决定，也可以改为100欧，但25欧因为阻值太低不常用）**到线缆，同时需要一个100nF的电容用于旁路**（滤波）

    这几个电阻就起到了阻抗匹配作用，计算公式如下
    $$
    Z=\sqrt{R-j\frac{1}{\omega C}}
    $$

3. 波形修复

    输出端的旁路电容可以有效对外传输线路上的噪声实现滤除

4. 抑制杂波

    电压型BS电路通过下拉到地的100nF滤波电容实现了滤出高频噪声的作用，而两个串联在变压器上的分压电阻配合变压器寄生电感可以提高电路对差模信号的抑制能力，从而滤除高频杂波，保证网口通信正常

    电流型BS电路则直接使用较高电流驱动的方式削弱从控制端输出的高频杂波影响。但是因为电流型电路会导致整体功耗较大，所以正在被电压型取代（不过在大功率信号传输的领域还是有一定应用）

5. 隔离高压

    这一条也可以称为**共模-差模防护**，电路可以通过一系列泻放路径抵抗从网络变压器输出端而来的浪涌电压电流。

    具体实现出于篇幅所限不在这里列出，大致思路就是*共模浪涌会被变压器和输出端电阻自行抵消，最多可能付出电容被击穿的代价，并不会伤害到控制端；而差模信号会被变压器引入到输入端，之后直接通过抽头的电容或上拉电阻被滤除，能够很大程度地减少对输入端和信号的影响*

> 在配置过程中发现：WAN口无法使用
>
> 重新刷入三次系统，反复调试一周后发现还是这样，基本上排除了所有可能的软件问题。于是决定回到硬件检查是否网络变压器或引脚出问题。首先用万用表通断档依次检测电容两端对地是否导通，发现WAN口的输入电容两端都对地为0——短路了；之后换用电阻档断电测量输入输出电阻，原本电路中使用75欧电阻，但测量中发现有两个电阻阻值不对，一个是偏小到50欧，另一个则无穷大。换掉电容电阻，上电接网线，成功秒杀

### 自定制并编译内核





#### 配环境







#### menuconfig





#### 漫长的编译







### 上位机连接到OpenWrt



#### Luci





#### 串口终端







#### SSH







#### 任何其他Linux发行版允许的登录方式





### 联网

OpenWrt一个突出特点就是自带了被称为opkg的包管理器，它和apt、yum、pacman等指令使用方式类似，能够不是太智能地只能解决软件包依赖问题：只能解决一点点。一般来说自动解决需要一层依赖的软件包安装还是可以的，但是为了安全起见还是一步一步的安装软件包吧











### 包管理器





```
--force-depends
```





### 换源



















snapshot版本和release版本区别

在java开发过程中，我们经常会看到代码仓库中的某些项目版本以release或snapshots结尾,现在说说这两个版本之间有什么区别.

一般来说snapshots版本代表正在开发中的版本,release代表比较稳定的发布版本.

比如我们新建一个maven项目,默认版本是这样的:

<groupId>com.example</groupId>
	<artifactId>demo</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>demo</name>
<description>Demo project</description>

    <groupId>com.example</groupId>
    	<artifactId>demo</artifactId>
    	<version>0.0.1-SNAPSHOT</version>
    	<name>demo</name>
    <description>Demo project</description>

上面0.0.1表示项目的版本号,表示这次迭代我要开发的所有主要功能都是属于这个版本的;
-SNAPSHOT表示该版本是快照版本,一般处于开发阶段,0.0.1版本还有功能没有完成,或还有bug还要修复,所以这个阶段一般代码更新比较频繁,开发人员写完代码会直接提交到代码仓库,这样之前依赖0.0.1-SNAPSHOT版本的开发人员也可以马上更新代码.
-Release表示是稳定版的,这次迭代的所有功能都已经完成,并且通过了测试之后,就可以发布为0.0.1-Release版本,Release版的一旦发布，就不要再改变代码了,所以如果之后在0.0.1-Release这个版本上发现了bug,需要修复,那么我们应该将0.0.1-Release版本改为0.0.2-SNAPSHOT,然后再修改bug并测试,没问题之后将0.0.2-SNAPSHOT改为0.0.2-Release发布.

使用maven的时候maven会根据pom文件中的version中是否带有-SNAPSHOT来判断是否是快照版本。如果是快照版本，在maven deploy时会发布到快照版本库中,依赖该版本的项目在编译打包时，maven会自动从maven仓库下载新的快照版本。如果是正式发布版本,deploy时会自动发布到正式版本库中，依赖该版本的项目在编译打包时如果本地已经存在该版本的工程默认不会从maven仓库下载新的版本.

所以如果现在开发的项目依赖了另外一个项目,如果不希望出现本来运行的好好地,过了一会儿因为依赖项目的更新突然不能运行了,那么可以选择依赖一个Release版本(如果有的话).









### 安装软件包



















