# C语言语法拾遗

C语言的语法





## 预处理和宏——灵魂



### 预处理指令的特殊用法

1. #

   预处理器对井号标记`#`有三种不同的用法：

   1. 标记一个指令

      这是最常用的方法，#之前的空白会被忽略，因此各种头文件的格式总是防止重复包含-引用-宏定义-变量定义-函数定义

   2. 输入的字符串化

      **使用#可以将一个变量转义为字符串，并且如果旁边有其它字符串相邻，会将他们合并在一起**

      这就是很多c程序处理字符串IO的方法

      ```c
      #define Pevel(cmd) printf(#cmd ":%g\n",cmd);
      ```

      上面的代码会将输入的变量cmd转换成字符串，输出变量名并输出对应的值

   3. 把符号连接起来

      使用两个##就可以将不是字符串的东西拼接在一起

      比如

      ```c
      name = LL;
      name##_list
      //等效于
      LL_list
      ```

      往往使用这种编程方法实现C语言的键值对（字典）轮子

2. 避免头文件包含

   这个用法很重要，懂得都懂。不懂的话自己写两个一模一样的.h文件碰几次报错就懂了

   使用方法有两种：

   ```c
   #ifndef __THIS_DOCUMENT
   #define __THIS_DOCUMENT
   
   /* 这里是头文件内容 */
   
   #endif
   ```

   或者

   ```c
   #pragma once
   ```

   这行语句只要加在文件开头即可通知编译器不进行二次包含，它实际上依赖于编译器，但每个主流的编译器都支持该指令

3. static和extern保护

   在.c库文件内的所有函数前使用static，并在.h文件中进行声明，可以对函数和变量进行一定的保护

   在含有很多全局变量，会被多处包含的.h头文件中使用extern声明全局变量可以防止多次重复编译；但是要注意：只在其中一个包含了该头文件的.c文件中进行变量定义

### typedef

使用typedef可以提高代码可读性、化简声明复杂度

还可以把一个结构体封装成一个“类”或封装出一个“方法”





### 可变参数宏

宏用于执行文本替换，但其思路和函数并不相同，并且它最大的特点就是：在预处理阶段完成替换，且遵循相对严格的替换原则

因此如果不仔细地写宏很容易造成错误！

宏一般能分成两类，一类是**表达式展开宏**：可以对这类宏进行求值，或宏干脆就是个数值，如下所示

```C
#define PI 3.14159265
#define T 2-1
#define one_to_ten 1/10
```

另一类是**指令展开宏**：一条甚至一系列指令，有可用的未知量，如下所示

```c
#define max m>n?m:n
#define u(x) x>0?x:0
#define t=t+1
```

为了编写鲁棒性更高（人话：更不容易出bug、易于移植）的宏，应遵循以下三条规则

* **多用括号**：把所有容易出bug的东西都括起来，防止重复错误和过度替换错误

* **代码块两端加入花括号**

  示例如下

  ```c
  #define doubleincrement(a, b) \
  		(a)++;				  \
  		(b)++;
  //上面这个例子容易出错，应该如下修改
  #define doubleincrement(a, b) \
  		{(a)++;				  \
  		(b)++;}
  //还有另外的方法，可以相当程度上保证代码块的安全
  #define doubleincrement(a,b) do{(a)++;(b)++;}while(0)
  //但是这种方法并不是万能的，要注意灵活变通！
  ```

* **避免重复作用**：使用注释等方法提醒用户不要做出越界的使用方法以免过度替换，并使用较少数量的参数，尽量防止参数过多导致bug

现代编译器中往往都会带有宏替换指示功能，Vim、Emacs甚至提供了一整套插件用于纠错，应该合理应用这些插件







## 指针与数组——C语言的底层

### 内存与变量

C语言提供了三种内存分配方式：

* **自动**

  一般的变量都是自动类型变量，显式或隐式使用auto标注地变量都使用自动内存分配

  在变量作用域中分配得内存，离开作用域后变量对应的内存区域被删除

* **静态**

  文件作用域内或函数中使用static声明的变量使用静态分配方式

  静态程序在整个生命周期内一直存在

  特别地，如果忘记对一个静态变量进行初始化，它会默认初始化为0或NULL

* **手动**

  使用free或malloc等C库函数进行手动分配内存

  如果手动分配内存出问题，很可能导致**段错误**

### C程序的底层结构

C程序经过编译后会形成如下几个结构进行保存：

* 堆栈段

  

* BSS段

  

* 代码段







任何函数都会在内存中占据一个空间，称为函数帧，函数帧会使用上面的结构保存与这个函数有关的所有信息。

> 比如下面这个程序
>
> ```c
> #include <stdio.h>
> 
> static int r=114;
> int q=514;
> 
> void foo(void);
> 
> int main(void)
> {
>     	int a=0;
>     	double b=0;
>     
>     	for(int i=0;i<r;i++)
>     	{
>         	foo();
>     	}
> }
> 
> void foo(void)
> {
>     	int k=1919;
>     	k++;
>     	printf("hello!\n");
> }
> ```
>
> 会被分成两个函数帧——main和foo进行保存
>
> 其中变量q和r会被作为全局变量保存在BSS段，a、b会被保存在main函数对应的堆栈段，i会被保存在for循环专属的堆栈段或程序堆栈段（根据编译器实现而不同），k会被保存在foo函数对应的堆栈段，两个函数中涉及到的操作指令都会保存在代码段
>
> 从main跳转到foo的步骤如下：
>
> 1. 保护现场，将main函数中属于堆栈段的变量（当前保存在寄存器）都压入main函数栈
> 2. 在执行for循环时根据条件/分支跳转指令确定跳转到foo，PS指向foo所在的代码段地址
> 3. 将foo中的变量k的值从foo函数栈中弹出，并加载到寄存器
> 4. 执行foo中的指令，执行完毕后执行保护现场操作
> 5. 执行恢复现场，继续执行main函数中的指令

在操作系统进行函数跳转时一般会采用分支跳转指令。更底层的实现可以参考计算机组成原理相关教程

**堆栈**

要注意：堆栈并不是堆+栈，堆栈就是堆栈

堆栈是内存中一块专门的区域，特点是*先入后出*

长度限制比一般内存小得多，专门用于保存自动变量，也用于临时保存寄存器中的值（保护现场）

堆栈段的内存分配一般由硬件/编译器/操作系统内存分配算法等底层处理系统实现

**堆**

通过手动方式分配的内存都会保存在堆空间，堆的实现根据操作系统或内存分配算法有所不同

堆是内存分配算法在内存中创建的内存池状数据结构

一般来说堆的大小就是可用内存的剩余大小

### C语言中的数据内存分配

C语言中的数据在进行内存分配时往往会遵循以下原则：

* 在函数外部声明或在函数内部使用static关键字声明一个变量，这个变量就是静态变量
* 在函数内部使用auto或无额外的关键字声明一个变量，这个变量就是动态变量
* 声明指针也遵循以上两种原则

在声明指针时虽然也遵守基本原则——指针会被保存为“指针变量”（一般的实现中，指针和long long或double具有相同的大小，8字节），但是它指向的东西可以是自动、静态、手动三种类型中的任意一种。这就是为什么需要使用malloc函数对指针指向的内容进行分配内存

这就要谈到指针和数组的不同：指针指向的是需要手工分配的内存区域；数组名则指向已经在数组初始化阶段完成自动分配的内存区域。初始化一个数组的实际过程如下：

1. 在栈上分配出一个空间，这个空间就等于数组的大小
2. 将数组名初始化为指针
3. 将该指针指向新分配的地址头部

### 状态机和静态变量

看如下的经典的递归计算斐波那契数列函数

```c
int fibonacci(void)
{
    if(n<=0)
    {
        return -1; //错误输入
    }
    else if(n == 1 || n == 2)
    {
        return 1;
    }
    else
    {
        int result = Fibonacci(n - 2) + Fibonacci(n - 1);
    }
}
```

它可以被用静态变量的方法替代

```c
int fibonacci(void)
{
    static int a1 = 0;
    static int a2 = 1;
    int out = a1 + a2;
    
    a1 = a2;
    a2 = out;
    return out;
}
```

这就将一个递归函数转化成了一个**状态机**

在C语言中实现状态机的关键就在于静态变量，它可以让一个函数内部的参数保持存在，从而达到多次调用、多次计数的效果

甚至在多线程程序中也可以使用`_Thread_local`关键字来实现单线程的静态变量

### 指针定向运算

声明一个数组实际上就是将指针进行了重定向的运算

```c
int buf[4];
buf[0]=3;
buf[2]=8;

//可以等价于

int *buf = (int*)malloc(4 * sizeof(int));
*(buf+0)=3;
*(buf+2)=8;
```

因此可以使用类似的方法实现数据“重定向”

```c
bit[0]=*(a);
bit[2]=*(a+2);
bit[3]=0x08;
bit[4]=*(b);
bit[6]=*(b+2);
bit[8]=*(b+4);
```

使用该方式可以提高代码可读性

同时也可以使用这种方法提高算法效率

```c
char* list[] = {
    "first",
    "second",
    "third",
    NULL
}

for(char** p = list; *p != NULL; p++)
{
    printf("%s\n",p[0]);
}
```

使用上述方法可以对字符串数组进行快速解析

也可以化简多维数组，这个应该算是老生常谈——**数组的数组就是指向指针的指针**





## 变量和数据类型——骨干



### 类型转换

类型转换常常会导致一些隐蔽的错误，尤其是在缺少编译器自动纠错辅助的情况下（某些逆大天的嵌入式编程IDE就是这样），下面列举一些常常会导致出错的问题和对应的解决方案

1. 两个整数相除总是返回整数

   可以使用“加0”的方法

   ```c
   4/3 == 2;
   4/(3+0.0) == 1.3333;
   4/3. == 1.3333;
   ```

   或直接显式进行类型转换

   ```c
   4/(double)3 == 1.3333;
   ```

2. 数组的索引必须是整数

   ```c
   int a[4];
   a[3.3]; //错误
   a[(int)3.3] == a[3]; //避免错误
   ```

   

### C面向对象







### C实现的类







### C实现的方法







### C实现的字典









### private和public









### 有限的运算符重载







### 一些经常被遗忘但在嵌入式编程中仍有作用的关键字

* volatile

  > 一个定义为volatile的变量是说这变量可能随时会被改变，这样编译器就不会去假设这个变量的值——优化器在用到这个变量时必须每次都会重新读取这个变量的值，而不是使用保存在寄存器里的备份

  这个关键字常被用于下面的场合：

  * 并行设备的硬件寄存器

    说人话就是**MCU的外设控制寄存器地址需要用volatile指明**

  * 一个中断服务子程序中会访问到的非自动变量

    这个就很明显了，**用于指示中断的全局变量**

  * 多线程应用中被几个任务共享的变量

    这种情况一般会在SMP设备或多核的高性能嵌入式设备中出现，**多核执行任务中一定将全局变量设为volatile**，否则可能导致跑飞。如果有双核并行化需求且对效率没有极致的需求，尽量使用RTOS甚至嵌入式Linux，并在分配任务的时候尽量使用RTOS自带的信号量或消息队列可以减少出现问题的可能性

  事实上volatile应该解释为“*直接存取原始内存地址*”，正因如此，**volatile是可以和const一起使用的**，这表示对于某个只读变量始终直接存取原始内存地址

  下面给一个网上随处可见的例子：

  ```c
  //下面的函数有什么错误?
  int square(volatile int *ptr)
  {
  	return *ptr * *ptr;
  } 
  ```

  这段代码的目的是用来返回指针ptr指向值的平方，但由于ptr指向一个volatile型参数，这个参数的值随时可能变化，编译器可能会将其优化为以下代码

  ```c
  int square(volatile int *ptr)
  {
  	int a,b;
  	a = *ptr;
  	b = *ptr;
  	return a * b;
  } 
  ```

  实际上编译器生成的是汇编指令，a、b并不影响存取变量，但是会消耗额外的内存空间、让CPU执行不必要的取址甚至分支跳转指令，并且如果外界因素导致ptr指向的变量变化，就会实实在在地影响函数的返回值——会从理论上的a\*a变成a\*b

  正确的代码应该像下面这样

  ```c
  int square(volatile int *ptr)
  {
  	int a;
  	a = *ptr;
  	return a * a;
  } 
  ```

  使用一个普通变量a来暂存ptr指向的值，虽然这样看似浪费了内存，但是和上面那段代码的内存占用实际上是一样的，并且能够避免出错

* extern

  在c语言中最不被重视但确实是最重要的关键字

  用于**在头文件中声明已在对应.c库文件中定义过的变量**

  也常用于**在多任务文件中定义main文件中的全局变量**

  没有这个关键字，编译器必报错，一改就是半天

* static

  static在不同作用域中有不同的含义

  * 全局变量static

    用于指示这个全局变量只在单文件中起作用，可以用于在.c文件中声明常量来提高文件的可移植性

  * 局部变量static

    用于指示静态局部变量，这个学过C语言的人应该都比较熟悉了

    最常见的用法是在MCU的按键扫描函数中使用，如下所示

    ```c
    unsigned char KEY_Scan(unsigned char mode)
    {	 
    	static u8 key_up=1;
        
        if(mode)
            key_up=1;
    	if(key_up && ( KEY0==1 || WK_UP==1 ))
    	{
    		delay_ms(10); //软件消抖
    		key_up=0;
    		if(KEY0==1)
                return KEY0_PRES;
    		else if(WK_UP==1)
                return WKUP_PRES;
    	}
        else if(KEY0==0 && WK_UP==0)
        {
    		key_up=1;
        }
     	return 0;
    }
    ```

  * 函数static

    用于声明某个函数是本文件内有效的函数

    同样用于在.c文件中声明常量来提高文件的可移植性

    一般来说会在.h文件中再写一条extern static标明的函数

    **static函数在内存中只有一份，普通函数会在每次调用中生成一份拷贝**

* register

  这个关键字确实很少使用，但是一旦用上就十有八九是需要硬优化算法的地方，如果实在需要使用这种方法优化，可以使用内联汇编来进行替代，不仅可以稳定”寄存器命中“，还可以更好地强调代码的执行速度优先

## 库函数与轮子——顶层







### 使用C库函数进行字符串处理

1. 将字符串转换为数字

   最基本的方法是使用`atoi`和`atof`

   使用方法如下

   ```c
   char a = "42";
   int x = atoi(a);
   
   char million[] = "1e6";
   double m = atof(million);
   ```

   更安全一点的库函数如下所示

   ```c
   int a = strtod(char string[],char *p);
   //里面的指针p会被指向第一个不能被解析成数字的字母
   ```

2. asprintf函数

   该函数需要使用支持GNU或BSD标准库的系统，但也可以使用vsnprintf函数快速实现asprintf函数

   该函数可以让字符串处理更方便

   ```c
   /* 一般的字符串处理方法 */
   #include <stdio.h>
   #include <string.h>
   #include <stdlib.h>
   
   void get_strings(char const *in)
   {
       char* cmd;
       int len = strlen("strings ") + strlen(in) + 1;
       cmd = malloc(len);
       snprintf(cmd, len, "strings %s", in);
       if(system(cmd))
       {
           fprintf(stderr, "something went wrong running %s.\n", cmd);
       }
       free(cmd);
   }
   
   /* 使用asprintf的字符串处理方法 */
   #define _GNU_SOURCE
   #include <stdio.h>
   #include <stdlib.h>
   
   void get_strings(char const *in)
   {
       char* cmd;
       asprintf(&cmd, "strings %s", in);
       if(system(cmd))
       {
           fprintf(stderr, "something went wrong running %s.\n", cmd);
       }
       free(cmd);
   }
   
   int main(int argc, char **argv)
   {
       get_strings(argv[0]);
       return 0;
   }
   ```

   asprintf和sprintf很相似，但是它需要传入的是字符串在内存中的位置而不是字符串本身，因为这个函数会为字符串分配新的空间

   可以通过运行两次vsnprintf来实现asprintf

   ```c
   
   ```

   







### 多线程







### 原子操作





### SQLite







### cJSON

















