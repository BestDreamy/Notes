# C语言语法拾遗

C语言的语法





## 预处理和宏——灵魂









## 指针与数组——C语言的底层

### 内存与变量

C语言提供了三种内存分配方式：

* **自动**

  一般的变量都是自动类型变量，显式或隐式使用auto标注地变量都使用自动内存分配

  在变量作用域中分配得内存，离开作用域后变量对应的内存区域被删除

* **静态**

  文件作用域内或函数中使用static声明的变量使用静态分配方式

  静态程序在整个生命周期内一直存在

  特别地，如果忘记对一个静态变量进行初始化，它会默认初始化为0或NULL

* **手动**

  使用free或malloc等C库函数进行手动分配内存

  如果手动分配内存出问题，很可能导致**段错误**

### C程序的底层结构

C程序经过编译后会形成如下几个结构进行保存：

* 堆栈段

  

* BSS段

  

* 代码段







任何函数都会在内存中占据一个空间，称为函数帧，函数帧会使用上面的结构保存与这个函数有关的所有信息。

> 比如下面这个程序
>
> ```c
> #include <stdio.h>
> 
> static int r=114;
> int q=514;
> 
> void foo(void);
> 
> int main(void)
> {
>     int a=0;
>     double b=0;
>     
>     for(int i=0;i<r;i++)
>     {
>         foo();
>     }
> }
> 
> void foo(void)
> {
>     int k=1919;
>     k++;
>     printf("hello!\n");
> }
> ```
>
> 会被分成两个函数帧——main和foo进行保存
>
> 其中变量q和r会被作为全局变量保存在BSS段，a、b会被保存在main函数对应的堆栈段，i会被保存在for循环专属的堆栈段或程序堆栈段（根据编译器实现而不同），k会被保存在foo函数对应的堆栈段，两个函数中涉及到的操作指令都会保存在代码段
>
> 从main跳转到foo的步骤如下：
>
> 1. 保护现场，将main函数中属于堆栈段的变量（当前保存在寄存器）都压入main函数栈
> 2. 在执行for循环时根据条件/分支跳转指令确定跳转到foo，PS指向foo所在的代码段地址
> 3. 将foo中的变量k的值从foo函数栈中弹出，并加载到寄存器
> 4. 执行foo中的指令，执行完毕后执行保护现场操作
> 5. 执行恢复现场，继续执行main函数中的指令

在操作系统进行函数跳转时一般会采用分支跳转指令。更底层的实现可以参考计算机组成原理相关教程

**堆栈**

要注意：堆栈并不是堆+栈，堆栈就是堆栈

堆栈是内存中一块专门的区域，特点是*先入后出*

长度限制比一般内存小得多，专门用于保存自动变量，也用于临时保存寄存器中的值（保护现场）

堆栈段的内存分配一般由硬件/编译器/操作系统内存分配算法等底层处理系统实现

**堆**

通过手动方式分配的内存都会保存在堆空间，堆的实现根据操作系统或内存分配算法有所不同

堆是内存分配算法在内存中创建的内存池状数据结构

一般来说堆的大小就是可用内存的剩余大小

### C语言中的数据内存分配

C语言中的数据在进行内存分配时往往会遵循以下原则：

* 在函数外部声明或在函数内部使用static关键字声明一个变量，这个变量就是静态变量
* 在函数内部使用auto或无额外的关键字声明一个变量，这个变量就是动态变量
* 声明指针也遵循以上两种原则

在声明指针时虽然也遵守基本原则——指针会被保存为“指针变量”（一般的实现中，指针和long long或double具有相同的大小，8字节），但是它指向的东西可以是自动、静态、手动三种类型中的任意一种。这就是为什么需要使用malloc函数对指针指向的内容进行分配内存









## 声明、引用、初始化——骨干











## 库函数与轮子——顶层



















