# C语言语法拾遗

C语言的语法





## 预处理和宏——灵魂









## 指针与数组——C语言的底层

### 内存与变量

C语言提供了三种内存分配方式：

* **自动**

  一般的变量都是自动类型变量，显式或隐式使用auto标注地变量都使用自动内存分配

  在变量作用域中分配得内存，离开作用域后变量对应的内存区域被删除

* **静态**

  文件作用域内或函数中使用static声明的变量使用静态分配方式

  静态程序在整个生命周期内一直存在

  特别地，如果忘记对一个静态变量进行初始化，它会默认初始化为0或NULL

* **手动**

  使用free或malloc等C库函数进行手动分配内存

  如果手动分配内存出问题，很可能导致**段错误**

### C程序的底层结构

C程序经过编译后会形成如下几个结构进行保存：

* 堆栈段

  

* BSS段

  

* 代码段







任何函数都会在内存中占据一个空间，称为函数帧，函数帧会使用上面的结构保存与这个函数有关的所有信息。

> 比如下面这个程序
>
> ```c
> #include <stdio.h>
> 
> static int r=114;
> int q=514;
> 
> void foo(void);
> 
> int main(void)
> {
>     	int a=0;
>     	double b=0;
>     
>     	for(int i=0;i<r;i++)
>     	{
>         	foo();
>     	}
> }
> 
> void foo(void)
> {
>     	int k=1919;
>     	k++;
>     	printf("hello!\n");
> }
> ```
>
> 会被分成两个函数帧——main和foo进行保存
>
> 其中变量q和r会被作为全局变量保存在BSS段，a、b会被保存在main函数对应的堆栈段，i会被保存在for循环专属的堆栈段或程序堆栈段（根据编译器实现而不同），k会被保存在foo函数对应的堆栈段，两个函数中涉及到的操作指令都会保存在代码段
>
> 从main跳转到foo的步骤如下：
>
> 1. 保护现场，将main函数中属于堆栈段的变量（当前保存在寄存器）都压入main函数栈
> 2. 在执行for循环时根据条件/分支跳转指令确定跳转到foo，PS指向foo所在的代码段地址
> 3. 将foo中的变量k的值从foo函数栈中弹出，并加载到寄存器
> 4. 执行foo中的指令，执行完毕后执行保护现场操作
> 5. 执行恢复现场，继续执行main函数中的指令

在操作系统进行函数跳转时一般会采用分支跳转指令。更底层的实现可以参考计算机组成原理相关教程

**堆栈**

要注意：堆栈并不是堆+栈，堆栈就是堆栈

堆栈是内存中一块专门的区域，特点是*先入后出*

长度限制比一般内存小得多，专门用于保存自动变量，也用于临时保存寄存器中的值（保护现场）

堆栈段的内存分配一般由硬件/编译器/操作系统内存分配算法等底层处理系统实现

**堆**

通过手动方式分配的内存都会保存在堆空间，堆的实现根据操作系统或内存分配算法有所不同

堆是内存分配算法在内存中创建的内存池状数据结构

一般来说堆的大小就是可用内存的剩余大小

### C语言中的数据内存分配

C语言中的数据在进行内存分配时往往会遵循以下原则：

* 在函数外部声明或在函数内部使用static关键字声明一个变量，这个变量就是静态变量
* 在函数内部使用auto或无额外的关键字声明一个变量，这个变量就是动态变量
* 声明指针也遵循以上两种原则

在声明指针时虽然也遵守基本原则——指针会被保存为“指针变量”（一般的实现中，指针和long long或double具有相同的大小，8字节），但是它指向的东西可以是自动、静态、手动三种类型中的任意一种。这就是为什么需要使用malloc函数对指针指向的内容进行分配内存









## 变量和数据类型——骨干







### 一些经常被遗忘但在嵌入式编程中仍有作用的关键字

* volatile

  > 一个定义为volatile的变量是说这变量可能随时会被改变，这样编译器就不会去假设这个变量的值——优化器在用到这个变量时必须每次都会重新读取这个变量的值，而不是使用保存在寄存器里的备份

  这个关键字常被用于下面的场合：

  * 并行设备的硬件寄存器

    说人话就是**MCU的外设控制寄存器地址需要用volatile指明**

  * 一个中断服务子程序中会访问到的非自动变量

    这个就很明显了，**用于指示中断的全局变量**

  * 多线程应用中被几个任务共享的变量

    这种情况一般会在SMP设备或多核的高性能嵌入式设备中出现，**多核执行任务中一定将全局变量设为volatile**，否则可能导致跑飞。如果有双核并行化需求且对效率没有极致的需求，尽量使用RTOS甚至嵌入式Linux，并在分配任务的时候尽量使用RTOS自带的信号量或消息队列可以减少出现问题的可能性

  事实上volatile应该解释为“*直接存取原始内存地址*”，正因如此，**volatile是可以和const一起使用的**，这表示对于某个只读变量始终直接存取原始内存地址

  下面给一个网上随处可见的例子：

  ```c
  //下面的函数有什么错误?
  int square(volatile int *ptr)
  {
  	return *ptr * *ptr;
  } 
  ```

  这段代码的目的是用来返回指针ptr指向值的平方，但由于ptr指向一个volatile型参数，这个参数的值随时可能变化，编译器可能会将其优化为以下代码

  ```c
  int square(volatile int *ptr)
  {
  	int a,b;
  	a = *ptr;
  	b = *ptr;
  	return a * b;
  } 
  ```

  实际上编译器生成的是汇编指令，a、b并不影响存取变量，但是会消耗额外的内存空间、让CPU执行不必要的取址甚至分支跳转指令，并且如果外界因素导致ptr指向的变量变化，就会实实在在地影响函数的返回值——会从理论上的a\*a变成a\*b

  正确的代码应该像下面这样

  ```c
  int square(volatile int *ptr)
  {
  	int a;
  	a = *ptr;
  	return a * a;
  } 
  ```

  使用一个普通变量a来暂存ptr指向的值，虽然这样看似浪费了内存，但是和上面那段代码的内存占用实际上是一样的，并且能够避免出错

* extern

  在c语言中最不被重视但确实是最重要的关键字

  用于**在头文件中声明已在对应.c库文件中定义过的变量**

  也常用于**在多任务文件中定义main文件中的全局变量**

  没有这个关键字，编译器必报错，一改就是半天

* static

  static在不同作用域中有不同的含义

  * 全局变量static

    用于指示这个全局变量只在单文件中起作用，可以用于在.c文件中声明常量来提高文件的可移植性

  * 局部变量static

    用于指示静态局部变量，这个学过C语言的人应该都比较熟悉了

    最常见的用法是在MCU的按键扫描函数中使用，如下所示

    ```c
    unsigned char KEY_Scan(unsigned char mode)
    {	 
    	static u8 key_up=1;
        
        if(mode)
            key_up=1;
    	if(key_up && ( KEY0==1 || WK_UP==1 ))
    	{
    		delay_ms(10); //软件消抖
    		key_up=0;
    		if(KEY0==1)
                return KEY0_PRES;
    		else if(WK_UP==1)
                return WKUP_PRES;
    	}
        else if(KEY0==0 && WK_UP==0)
        {
    		key_up=1;
        }
     	return 0;
    }
    ```

  * 函数static

    用于声明某个函数是本文件内有效的函数

    同样用于在.c文件中声明常量来提高文件的可移植性

    一般来说会在.h文件中再写一条extern static标明的函数

    **static函数在内存中只有一份，普通函数会在每次调用中生成一份拷贝**

* register

  这个关键字确实很少使用，但是一旦用上就十有八九是需要硬优化算法的地方，如果实在需要使用这种方法优化，可以使用内联汇编来进行替代，不仅可以稳定”寄存器命中“，还可以更好地强调代码的执行速度优先

## 库函数与轮子——顶层



















