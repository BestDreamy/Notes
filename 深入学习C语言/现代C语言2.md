# C语言语法拾遗

C语言的语法





## 预处理和宏——灵魂



### typedef

使用typedef可以提高代码可读性、化简声明复杂度

还可以把一个结构体封装成一个“类”或封装出一个“方法”





### 可变参数宏











## 指针与数组——C语言的底层

### 内存与变量

C语言提供了三种内存分配方式：

* **自动**

  一般的变量都是自动类型变量，显式或隐式使用auto标注地变量都使用自动内存分配

  在变量作用域中分配得内存，离开作用域后变量对应的内存区域被删除

* **静态**

  文件作用域内或函数中使用static声明的变量使用静态分配方式

  静态程序在整个生命周期内一直存在

  特别地，如果忘记对一个静态变量进行初始化，它会默认初始化为0或NULL

* **手动**

  使用free或malloc等C库函数进行手动分配内存

  如果手动分配内存出问题，很可能导致**段错误**

### C程序的底层结构

C程序经过编译后会形成如下几个结构进行保存：

* 堆栈段

  

* BSS段

  

* 代码段







任何函数都会在内存中占据一个空间，称为函数帧，函数帧会使用上面的结构保存与这个函数有关的所有信息。

> 比如下面这个程序
>
> ```c
> #include <stdio.h>
> 
> static int r=114;
> int q=514;
> 
> void foo(void);
> 
> int main(void)
> {
>     	int a=0;
>     	double b=0;
>     
>     	for(int i=0;i<r;i++)
>     	{
>         	foo();
>     	}
> }
> 
> void foo(void)
> {
>     	int k=1919;
>     	k++;
>     	printf("hello!\n");
> }
> ```
>
> 会被分成两个函数帧——main和foo进行保存
>
> 其中变量q和r会被作为全局变量保存在BSS段，a、b会被保存在main函数对应的堆栈段，i会被保存在for循环专属的堆栈段或程序堆栈段（根据编译器实现而不同），k会被保存在foo函数对应的堆栈段，两个函数中涉及到的操作指令都会保存在代码段
>
> 从main跳转到foo的步骤如下：
>
> 1. 保护现场，将main函数中属于堆栈段的变量（当前保存在寄存器）都压入main函数栈
> 2. 在执行for循环时根据条件/分支跳转指令确定跳转到foo，PS指向foo所在的代码段地址
> 3. 将foo中的变量k的值从foo函数栈中弹出，并加载到寄存器
> 4. 执行foo中的指令，执行完毕后执行保护现场操作
> 5. 执行恢复现场，继续执行main函数中的指令

在操作系统进行函数跳转时一般会采用分支跳转指令。更底层的实现可以参考计算机组成原理相关教程

**堆栈**

要注意：堆栈并不是堆+栈，堆栈就是堆栈

堆栈是内存中一块专门的区域，特点是*先入后出*

长度限制比一般内存小得多，专门用于保存自动变量，也用于临时保存寄存器中的值（保护现场）

堆栈段的内存分配一般由硬件/编译器/操作系统内存分配算法等底层处理系统实现

**堆**

通过手动方式分配的内存都会保存在堆空间，堆的实现根据操作系统或内存分配算法有所不同

堆是内存分配算法在内存中创建的内存池状数据结构

一般来说堆的大小就是可用内存的剩余大小

### C语言中的数据内存分配

C语言中的数据在进行内存分配时往往会遵循以下原则：

* 在函数外部声明或在函数内部使用static关键字声明一个变量，这个变量就是静态变量
* 在函数内部使用auto或无额外的关键字声明一个变量，这个变量就是动态变量
* 声明指针也遵循以上两种原则

在声明指针时虽然也遵守基本原则——指针会被保存为“指针变量”（一般的实现中，指针和long long或double具有相同的大小，8字节），但是它指向的东西可以是自动、静态、手动三种类型中的任意一种。这就是为什么需要使用malloc函数对指针指向的内容进行分配内存

这就要谈到指针和数组的不同：指针指向的是需要手工分配的内存区域；数组名则指向已经在数组初始化阶段完成自动分配的内存区域。初始化一个数组的实际过程如下：

1. 在栈上分配出一个空间，这个空间就等于数组的大小
2. 将数组名初始化为指针
3. 将该指针指向新分配的地址头部

### 状态机和静态变量

看如下的经典的递归计算斐波那契数列函数

```c
int fibonacci(void)
{
    if(n<=0)
    {
        return -1; //错误输入
    }
    else if(n == 1 || n == 2)
    {
        return 1;
    }
    else
    {
        int result = Fibonacci(n - 2) + Fibonacci(n - 1);
    }
}
```

它可以被用静态变量的方法替代

```c
int fibonacci(void)
{
    static int a1 = 0;
    static int a2 = 1;
    int out = a1 + a2;
    
    a1 = a2;
    a2 = out;
    return out;
}
```

这就将一个递归函数转化成了一个**状态机**

在C语言中实现状态机的关键就在于静态变量，它可以让一个函数内部的参数保持存在，从而达到多次调用、多次计数的效果

甚至在多线程程序中也可以使用`_Thread_local`关键字来实现单线程的静态变量

### 指针定向运算

声明一个数组实际上就是将指针进行了重定向的运算

```c
int buf[4];
buf[0]=3;
buf[2]=8;

//可以等价于

int *buf = (int*)malloc(4 * sizeof(int));
*(buf+0)=3;
*(buf+2)=8;
```

因此可以使用类似的方法实现数据“重定向”

```c
bit[0]=*(a);
bit[2]=*(a+2);
bit[3]=0x08;
bit[4]=*(b);
bit[6]=*(b+2);
bit[8]=*(b+4);
```

使用该方式可以提高代码可读性

同时也可以使用这种方法提高算法效率

```c
char* list[] = {
    "first",
    "second",
    "third",
    NULL
}

for(char** p = list; *p != NULL; p++)
{
    printf("%s\n",p[0]);
}
```

使用上述方法可以对字符串数组进行快速解析

也可以化简多维数组，这个应该算是老生常谈——**数组的数组就是指向指针的指针**





## 变量和数据类型——骨干



### 类型转换

类型转换常常会导致一些隐蔽的错误，尤其是在缺少编译器自动纠错辅助的情况下（某些逆大天的嵌入式编程IDE就是这样），下面列举一些常常会导致出错的问题和对应的解决方案

1. 两个整数相除总是返回整数

   可以使用“加0”的方法

   ```c
   4/3 == 2;
   4/(3+0.0) == 1.3333;
   4/3. == 1.3333;
   ```

   或直接显式进行类型转换

   ```c
   4/(double)3 == 1.3333;
   ```

2. 数组的索引必须是整数

   ```c
   int a[4];
   a[3.3]; //错误
   a[(int)3.3] == a[3]; //避免错误
   ```

   

### C面向对象







### C实现的类







### C实现的方法







### C实现的字典









### private和public









### 有限的运算符重载







### 一些经常被遗忘但在嵌入式编程中仍有作用的关键字

* volatile

  > 一个定义为volatile的变量是说这变量可能随时会被改变，这样编译器就不会去假设这个变量的值——优化器在用到这个变量时必须每次都会重新读取这个变量的值，而不是使用保存在寄存器里的备份

  这个关键字常被用于下面的场合：

  * 并行设备的硬件寄存器

    说人话就是**MCU的外设控制寄存器地址需要用volatile指明**

  * 一个中断服务子程序中会访问到的非自动变量

    这个就很明显了，**用于指示中断的全局变量**

  * 多线程应用中被几个任务共享的变量

    这种情况一般会在SMP设备或多核的高性能嵌入式设备中出现，**多核执行任务中一定将全局变量设为volatile**，否则可能导致跑飞。如果有双核并行化需求且对效率没有极致的需求，尽量使用RTOS甚至嵌入式Linux，并在分配任务的时候尽量使用RTOS自带的信号量或消息队列可以减少出现问题的可能性

  事实上volatile应该解释为“*直接存取原始内存地址*”，正因如此，**volatile是可以和const一起使用的**，这表示对于某个只读变量始终直接存取原始内存地址

  下面给一个网上随处可见的例子：

  ```c
  //下面的函数有什么错误?
  int square(volatile int *ptr)
  {
  	return *ptr * *ptr;
  } 
  ```

  这段代码的目的是用来返回指针ptr指向值的平方，但由于ptr指向一个volatile型参数，这个参数的值随时可能变化，编译器可能会将其优化为以下代码

  ```c
  int square(volatile int *ptr)
  {
  	int a,b;
  	a = *ptr;
  	b = *ptr;
  	return a * b;
  } 
  ```

  实际上编译器生成的是汇编指令，a、b并不影响存取变量，但是会消耗额外的内存空间、让CPU执行不必要的取址甚至分支跳转指令，并且如果外界因素导致ptr指向的变量变化，就会实实在在地影响函数的返回值——会从理论上的a\*a变成a\*b

  正确的代码应该像下面这样

  ```c
  int square(volatile int *ptr)
  {
  	int a;
  	a = *ptr;
  	return a * a;
  } 
  ```

  使用一个普通变量a来暂存ptr指向的值，虽然这样看似浪费了内存，但是和上面那段代码的内存占用实际上是一样的，并且能够避免出错

* extern

  在c语言中最不被重视但确实是最重要的关键字

  用于**在头文件中声明已在对应.c库文件中定义过的变量**

  也常用于**在多任务文件中定义main文件中的全局变量**

  没有这个关键字，编译器必报错，一改就是半天

* static

  static在不同作用域中有不同的含义

  * 全局变量static

    用于指示这个全局变量只在单文件中起作用，可以用于在.c文件中声明常量来提高文件的可移植性

  * 局部变量static

    用于指示静态局部变量，这个学过C语言的人应该都比较熟悉了

    最常见的用法是在MCU的按键扫描函数中使用，如下所示

    ```c
    unsigned char KEY_Scan(unsigned char mode)
    {	 
    	static u8 key_up=1;
        
        if(mode)
            key_up=1;
    	if(key_up && ( KEY0==1 || WK_UP==1 ))
    	{
    		delay_ms(10); //软件消抖
    		key_up=0;
    		if(KEY0==1)
                return KEY0_PRES;
    		else if(WK_UP==1)
                return WKUP_PRES;
    	}
        else if(KEY0==0 && WK_UP==0)
        {
    		key_up=1;
        }
     	return 0;
    }
    ```

  * 函数static

    用于声明某个函数是本文件内有效的函数

    同样用于在.c文件中声明常量来提高文件的可移植性

    一般来说会在.h文件中再写一条extern static标明的函数

    **static函数在内存中只有一份，普通函数会在每次调用中生成一份拷贝**

* register

  这个关键字确实很少使用，但是一旦用上就十有八九是需要硬优化算法的地方，如果实在需要使用这种方法优化，可以使用内联汇编来进行替代，不仅可以稳定”寄存器命中“，还可以更好地强调代码的执行速度优先

## 库函数与轮子——顶层







### 使用C库函数进行字符串处理









### 多线程







### 原子操作





### SQLite







### cJSON

















