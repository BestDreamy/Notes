本博文参考胡伟武《计算机体系结构基础》、P-H《计算机组成与设计-硬件/软件接口（RISC-V版）》和Bryant《深入理解计算机系统》写作。笔者系初学，如有错误敬请指正。

# 计算机体系结构笔记4【流水线和冒险】

## 取指

**每条指令在存储器空间中所处的地址称为它的指令PC**，**取址**指处理器核将指令（按照其指令PC值对应的存储器地址）从存储器中读取出来的过程

取址的目标如下：

* 快速取址
* 连续取址

可能面对的问题如下：

* 指令的编码宽度不相等，导致PC地址与地址边界无法对齐
* 分支跳转指令执行后，可能导致跳转到另一个不连续的PC处，取址时需要从新的PC值对应的存储器地址读出指令
* 处理器会按顺序执行非分支跳转指令，需要按顺序从存储器中读取指令

传统RISC架构处理器的解决方案

* 连续不断地从存储器中顺序读取出非分支跳转指令，即使是地址不对齐的32位指令，也应该能每个周期读出一条完整指令
* 能够快速判断在分支跳转指令中是否跳转，如果需要跳转，则从新的PC地址处快速取出指令，力求每个周期读出一条完整指令

### 普通指令取指

使用**剩余缓存**保存上次取指后没有用完的比特位，供下次使用

例如：从ITCM中取出一个32位的指令字，但只用到了它的低16位，则

1. 只需要使用此次取出的32位中低16位指令和之前取出32位中高16位指令组成一个32位指令，再进行执行
2. 指令长度本身就是16位，将其暂存在剩余缓存中，等待下一个周期取出下一个32位指令字后再拼接出完整指令执行

### 分支跳转指令取指

如果分支跳转指令的目标地址与32位地址边界不对齐，且需要取出一个32位的指令字，则剩余缓存的解决方案失效！

这种情况下常**使用多体化的SRAM进行指令存储**

常见的形式为**奇偶交替**：使用两块32位宽的SRAM交错地进行存储，将两个32位指令字分别存储在两块不同的SRAM中，这样就可以在一个时钟周期内访问两块SRAM并取出两个连续的32位关键字，然后拼接形成真正的32位指令

### 分支预测

1. 静态分支预测

    不依赖任何执行过的指令信息和历史信息，凭借当前分支指令本身的信息进行预测

    **最简分支预测**：总是预测分支指令不会发生跳转，如果执行阶段发现需要跳转，则冲刷流水线重新取指，会造成两个时钟周期的流水线延迟

    **分支延迟槽**：每一条分支指令后面紧跟的一条或若干条指令不受分支跳转的影响，不管分支是否跳转，后面的指令都一定会被执行。分支延迟槽中的指令永远被执行而不用被丢弃重取，它不会受到冲刷流水线的影响

    **BTFN预测**（Back Taken，Forward Not Taken）：对向后跳转预测为跳，向前跳转预测为不跳，比较常见

2. 动态分支预测

    依赖已经执行过的历史信息和分支指令本身的信息综合进行*方向*预测

    **一比特饱和计数器**：最简单的动态预测器，每次分支指令执行后就会使用此计数器记录上次的方向，采用*下一次分支指令永远采用上次记录的方向*作为本次的预测

    **两比特饱和计数器**：最常见的动态预测器，采用FSM的方式进行预测。

    当前状态=强不需要跳转 或 弱不需要跳转，则预测该指令方向为 不需要跳转

    当前状态=弱需要跳转 或 强需要跳转，则预测该指令方向为 需要跳转

    如果预测出错，则反向更改当前状态：从 强需要跳转 要出错连续2次才能变为变为 弱不需要跳转，因此具有一定的切换缓冲，其在复杂程序流中预测精度一般比简单的一比特饱和计数器更高

    但是使用该方案可能会导致**别名重合**：使用多个两比特饱和计数器负责不同分支指令的预测，会导致大量空间占用，所以只能采用有限个计数器组成计数器表格，但表项数目有限但指令众多，所以很多不同的分支会不可避免地指向相同的表项

解决这个问题一般采用**动态分支预测算法**：采用不同的表格组织方式（控制表格大小）和索引方式（控制别名重合问题）来提高预测精准率，常见算法如下：

1) 一级预测器

将有限个两比特饱和计数器组织成**一维表格**，称为**预测器表格**。直接使用PC值的一部分进行索引

“一级预测器”指的是其索引仅仅采用指令本身的PC值

优点：简单易行

缺点：索引机制过于简单导致预测精度不高

2) 两级预测器

又称为**相关预测器**

对于每条分支，将有限个两比特饱和计数器组织成PHT（Pattern History Table），使用该分支跳转的历史作为PHT的索引

只需要n个bit就能索引2^n^个表项

分支历史又可以分为局部历史（每个分支指令自己的跳转历史）和全局历史（所有分支指令的跳转历史）

**局部分支预测器**采用分立的局部历史缓存，每个缓存有自己对应的PHT，对于每条分支指令，会先索引其对应的局部历史缓存，再使用局部历史缓存中的历史值所引导对应的PHT

**全局分支预测器**使用所有分支指令共享的全局历史缓存。这个解决方案节省资源但只有在PHT容量非常大时才能体现出其优势，且PHT容量越大，优势越明显

常见的全局预测算法有：

* Gshare算法：将分支指令PC值的一部分和共享的全局历史缓存进行**异或**，使用运算的结果作为PHT的索引
* Gselect算法：将分支指令PC值的一部分和共享的全局历史缓存进行**拼接**，使用运算的结果作为PHT的索引

3. 预测地址

分支目标地址需要在**执行阶段计算后才能得到分支的目标地址**，这些任务无法在一个周期内完成，在连续取下一条指令前，甚至连译码判断当前指令是否属于分支指令都无法及时地在一个周期内完成，因此为了连续不断地取指，需要预测分支的目标地址，常见技术如下

1) BTB（Branch Target Buffer分支目标缓存）：使用容量有限的**缓存**保存最近执行过的分支指令的PC值及它们的跳转目标地址。对于后续需要取指的每条PC值，将其与BTB中存储的各个PC值进行比较，如果出现匹配则预测这是一条分支指令，使用其对应存储的跳转目标地址作为预测的跳转地址

优点：最简单快捷

缺点：1. BTB容量与时序、面积难以平衡；2. 对于间接跳转/分支指令的预测效果并不理想

2) RAS（Return Address Stack返回堆栈地址）：使用容量有限的**硬件堆栈**（FIFO）来存储函数调用的返回地址

间接分支/跳转指令多用于函数调用/返回，这两者成对出现，因此可以在函数调用时PC+=4或2，将其顺序执行的下一条指令的PC值压入RAS堆栈，等到函数返回时将其弹出，只要程序正常执行，RAS就能提供较高的预测准确率。不过由于RAS深度有限，出现多次函数嵌套则可能堆栈溢出，影响准确率

优点：正常情况下准确率高

缺点：出现函数嵌套时难以处理

3) Indirect BTB（间接BTB）：专门为间接分支/跳转指令设计的BTB，它通过高级的索引方法进行匹配，结合BTB和动态两级预测器的技术

优点：预测成功率很高

缺点：硬件开销非常大

4. 其它扩展技术

## 执行

经典五级流水线结构中，取指-译码-执行分为三个阶段进行，通过译码让CPU获取指令读取/写回的操作数寄存器索引、指令类型、指令操作信息等。目前高性能处理器普遍采用在每个运算单元前配置乱序发射队列的方式，将指令的相关性解除，从发射队列中发射出来时读取通用寄存器组，再送给运算单元进行计算

五级流水线架构中的执行需要译码之后执行，根据指令的具体操作类型将指令分配给不同的运算单元执行，常见的运算单元如下：

* 算术逻辑运算单元（ALU）：负责普通逻辑运算、加减法运算、移位运算等
* 整数乘法单元：主要负责有符号数或无符号整数的乘法
* 整数除法单元：主要负责有符号数或无符号整数的除法
* 浮点运算单元（FPU）：比较复杂，通常会分成多个不同的独立运算单元

对于其他具有特殊指令的处理器核，会相应增加特殊的运算单元（比如可以在处理器旁挂载DSP等硬件加速电路）

### 执行阶段的分支解析

取指阶段的分支预测功能对于带条件的分支指令，由于器条件解析需要进行操作数运算，所以需要在执行阶段进行运算并判断该分支指令是否真的需要跳转，并按照之前规定的分支预测算法进行对比执行，如果预测错误很可能需要进行流水线冲刷、造成性能损失

一般为了减少性能损失，会在比较靠前的流水线位置进行分支解析

### 数据冲突和冒险

流水线冲突包括资源冲突和数据冲突两类，这两种冲突都会导致流水线阻塞。**数据冲突**顾名思义，就是由于数据相关性引起的冲突。**资源冲突**通常发生在指令派遣给不同的执行单元进行执行的过程中，当一个指令被执行时耗费的时钟周期较长，此后又有其他指令被派发给同一个硬件模块进行处理的情况下便会出现资源冲突的情况——后续的指令需要等待前一个指令完成操作后将硬件模块释放出来后才能得到执行。

## 中断和异常

一般来说由处理器内部的事件或程序执行中的事件引起的程序跳转称为异常；由处理器外部因素引起的程序跳转称为中断。广义上来说中断和异常都被处理器视为**异常**，在硬件层次将其分为**同步异常**和**异步异常**

### 同步异常和异步异常

**同步异常**：由于执行程序指令流或者试图执行程序指令流而造成的异常

表现：CPU外部环境一定，多次执行时每次能够精确复现

常见的同步异常包括但不限于：

* 取指令访问到非法的地址区间
* 读写数据访问地址属性出错
* 取指令地址非对齐错误
* 非法指令错误
* 执行调试断点指令

**异步异常**：产生原因不能被精确定位于某条指令的异常

表现：CPU外部环境一定，但是每次发生异常的指令PC都可能会不一样

最常见的异步异常就是*外部中断*。外部中断的发生和中断请求到达时处理器执行的指令都是不确定的，这就导致很难出现反复执行同一条指令时恰好发生外部中断。==外部中断也因此常常被直接用“异步异常中断”指代==

根据处理器响应异常后的状态，可以分为精确异步异常和非精确异步异常

响应异常后处理器状态能精确反映为某一条指令的边界的情况称为**精确异步异常**

> 外部中断狭义来讲就是一种精确异步异常：执行完以后还会返回到原来断开的指令处继续执行

响应异常后处理器状态不能精确反映为某一条指令的边界的情况称为**非精确异步异常**

> 读写存储器出错是一种最常见的非精确异步异常
>
> 访问存储器时处理器还会接着执行指令，如果在此期间出现了访问错误进而触发异常，处理器会在处理到之后的某条指令时进入异常服务程序，难以预测当前执行到了哪个指令
>
> 写入缓存行时，也可能发生类似的错误，具体的原理与访问情况类似

在只考虑指令集的情况下，我们可以将异常广泛地分成：

* **外部中断**：精确异步异常，触发后交由中断服务程序处理，并根据指令集规定完成恢复现场
* **指令执行中的错误**：若指令的操作码或操作数不符合指令集规范，导致指令无法被执行，一定会触发同步异常
* **数据完整性问题**：当使用ECC等硬件校验方式的存储器发生校验错误时会产生非精确异步异常
* **系统调用和指令集规定的功能性异常**：指令集会为顶层的操作系统提供一定支持，最重要的就是提供一套供线程上下文切换的异常，并为更上层运行在用户态的应用程序提供一个进入内核态的方法，也就是系统调用异常；一些指令集也会提供预留的异常指令，执行到对应指令后会执行异常服务。这些异常都是同步异常
* **地址转换异常**：使用虚拟内存的系统需要对内存页进行地址转换，当转换表中没有有效的对应项可用时会产生该非精确异步异常
* **需要软件修正的运算**：指令集中会规定一些特定场景由软件处理，比如操作系统的线程调度、浮点运算、向量运算、除0运算等，一旦发生这些运算，就会触发精确异步异常

### 异常服务

异常从触发到被CPU响应再到完成处理的过程被称为**异常服务**（Exception Handler），用于处理异常的软件程序被称为异常服务程序或异常服务函数

一般来说异常服务过程由以下四步构成

1. CPU接收到异常信号

    首先阻塞取指，接收到异常前的所有指令都应该被执行完；被异常打断的指令（被称为**EPTR**）和以后的所有指令都被停止执行，如果是已经加载到流水线内，那么需要执行流水线冲刷以防止产生数据相关性。EPTR会被存储在特殊寄存器中，根据指令集不同，如果处理器微架构支持精确异步异常，那么可以忽略由EPTR带来的相关性问题

2. 确定异常源

    一般指令集会规定一个异常向量表（Exception Vector Table），写在存储器的某一区域，里面规定了异常代号和其对应异常服务程序的函数指针（入口地址）。处理器一旦接收到异常信号，就会去查找该表，获得当前需要跳转到的异常服务程序地址

3. 保存现场

    处理器确定异常源后会将当前寄存器压栈，根据需要关闭或保留部分中断，防止异常处理过程中产生新的中断影响到程序执行；完成保存现场的同时，会将异常向量表中对应的异常服务程序地址加载到PC，完成跳转

4. 执行异常服务程序

5. 恢复现场

    异常处理结束后，首先从栈恢复通用寄存器的值，并执行异常返回指令，从而到EPTR处继续执行。

特别地，如果异常服务过程中，还有新的异常产生，就会导致**异常嵌套**，各个指令集会采用不同的思路解决异常嵌套问题，包括迭代异常服务、嵌套中断服务等。这些解决方法大都需要保存被打断的异常处理程序状态，这就会消耗一定栈资源，因此不可能实现无限异常嵌套。系统会使用一个优先级系统，让高优先级异常能够打断低优先级异常，同级别异常只能够依次执行，这样**系统支持的优先级级数就是异常嵌套的最大层数**。

当然，优先级会带来硬件资源损耗和可能的软件延迟，处理器架构中会采用*衔尾中断*来尽可能减小损耗

> 衔尾中断可以参考ARM Cortex-M3内核的微架构实现

### 外部中断

对于桌面级和更高性能的处理器来说，缺页异常是非常常见的；对于MCU和大吞吐量的服务器处理器，外部中断是非常常见的；对搭载了操作系统的处理器，系统调用异常是非常常见的；这三种异常出现的概率远远高于其他任何异常。

特别地，系统调用异常是同步异常，可以被很好地处理；但缺页异常和外部中断都是异步异常，难以被定位，

一般的现代指令集包含两类中断：**可屏蔽中断**（Interrupt，**INT**）和**不可屏蔽中断**（Non-Maskable Interrupt，**NMI**）。INT用于表达外设的中断请求，可以通过特殊寄存器来屏蔽接收；NMI则用于处理致命的硬件错误，无法被屏蔽

传统的RISC处理器中，不使用中断向量表（也就是异常向量表，不过是指其中涉及到中断的部分），而使用一个固定的入口地址，由软件区分中断源。而现代处理器往往引入一个动态的中断向量表，每种中断的服务函数都有自己的入口地址，硬件完成异常来源溯源工作，这大大优化了处理器的实时性，该策略被称为**向量化中断**

中断从外设传递到处理器的方式主要有两种：中断线和消息中断。每个外设直接将中断信号连接到处理器端口，若信号较多，则先引入**中断控制器**（Interrupt Controller，IC），中断控制器处理信号的优先级关系和屏蔽中断，最后通过一组窄位宽中断信号线引入处理器。在高性能处理器中，常常使用消息中断，尤其是具有多核互联结构的处理器中，中断被编码为一组数据，在系统总线上传输，具有更高的扩展性——牺牲了一定实时性。在NoC（Net on Chip，片上网络）结构中，消息中断可以实现更高速的核间互联

### 缺页异常

现代桌面CPU都会采用虚拟内存（Virtual Memory），具体内容会在后续介绍。

虚拟内存是将硬盘这种缓慢的非易失性存储器中的数据动态映射到内存这种较快的易失性存储器中的技术，主要目的是*提供更大的内存空间*和*保障内核安全隔离*（安全虚拟化）。使用了虚拟内存技术的处理器会使用到**虚拟内存地址**和**物理内存地址**两套东西——处理器内部产生的是虚拟内存地址，由MMU将其转换成物理内存地址，这样就能够实现物理内存的虚拟化；操作系统再将内存空间划分成若干个固定大小的**页**，并维护了一套记录了虚拟页和物理页地址的**页表**，这样处理器只需要查表就可以完成虚拟内存地址和物理内存地址的转换。为了更快进行转换，MMU还会实现一个**转换后援缓存**（Translation Lookaside Buffer，**TLB**）来存储当前最常访问页的页表，处理器会优先访问TLB来进行虚拟内存转换。

了解过基础情况后，不难理解如果处理器没能在TLB中找到要访问的地址，就会产生**TLB缺页异常**，这时需要寻找到目标页表并将页表从内存中取出并填入TLB，这个过程称为**TLB充填**。这个过程可以由软件完成也可以由硬件完成——如果使用硬件完成则不会触发异常

此外，TLB还经常发生无效（要访问的物理页不在内存中）、修改（试图写只读页）等异常，具体异常种类与指令集有关