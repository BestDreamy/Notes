本博文参考胡伟武《计算机体系结构基础》、P-H《计算机组成与设计-硬件/软件接口（RISC-V版）》和Bryant《深入理解计算机系统》写作。笔者系初学，如有错误敬请指正。

# 计算机体系结构笔记4【流水线和冒险】

## 取指

**每条指令在存储器空间中所处的地址称为它的指令PC**，**取址**指处理器核将指令（按照其指令PC值对应的存储器地址）从存储器中读取出来的过程

取址的目标如下：

* 快速取址
* 连续取址

可能面对的问题如下：

* 指令的编码宽度不相等，导致PC地址与地址边界无法对齐
* 分支跳转指令执行后，可能导致跳转到另一个不连续的PC处，取址时需要从新的PC值对应的存储器地址读出指令
* 处理器会按顺序执行非分支跳转指令，需要按顺序从存储器中读取指令

传统RISC架构处理器的解决方案

* 连续不断地从存储器中顺序读取出非分支跳转指令，即使是地址不对齐的32位指令，也应该能每个周期读出一条完整指令
* 能够快速判断在分支跳转指令中是否跳转，如果需要跳转，则从新的PC地址处快速取出指令，力求每个周期读出一条完整指令

### 普通指令取指

使用**剩余缓存**保存上次取指后没有用完的比特位，供下次使用

例如：从ITCM中取出一个32位的指令字，但只用到了它的低16位，则

1. 只需要使用此次取出的32位中低16位指令和之前取出32位中高16位指令组成一个32位指令，再进行执行
2. 指令长度本身就是16位，将其暂存在剩余缓存中，等待下一个周期取出下一个32位指令字后再拼接出完整指令执行

### 分支跳转指令取指

如果分支跳转指令的目标地址与32位地址边界不对齐，且需要取出一个32位的指令字，则剩余缓存的解决方案失效！

这种情况下常**使用多体化的SRAM进行指令存储**

常见的形式为**奇偶交替**：使用两块32位宽的SRAM交错地进行存储，将两个32位指令字分别存储在两块不同的SRAM中，这样就可以在一个时钟周期内访问两块SRAM并取出两个连续的32位关键字，然后拼接形成真正的32位指令

### 分支预测

      1. 静态分支预测

不依赖任何执行过的指令信息和历史信息，凭借当前分支指令本身的信息进行预测

**最简分支预测**：总是预测分支指令不会发生跳转，如果执行阶段发现需要跳转，则冲刷流水线重新取指，会造成两个时钟周期的流水线延迟

**分支延迟槽**：每一条分支指令后面紧跟的一条或若干条指令不受分支跳转的影响，不管分支是否跳转，后面的指令都一定会被执行。分支延迟槽中的指令永远被执行而不用被丢弃重取，它不会受到冲刷流水线的影响

**BTFN预测**（Back Taken，Forward Not Taken）：对向后跳转预测为跳，向前跳转预测为不跳，比较常见

      2. 动态分支预测

依赖已经执行过的历史信息和分支指令本身的信息综合进行*方向*预测

**一比特饱和计数器**：最简单的动态预测器，每次分支指令执行后就会使用此计数器记录上次的方向，采用*下一次分支指令永远采用上次记录的方向*作为本次的预测

**两比特饱和计数器**：最常见的动态预测器，采用FSM的方式进行预测。

当前状态=强不需要跳转 或 弱不需要跳转，则预测该指令方向为 不需要跳转

当前状态=弱需要跳转 或 强需要跳转，则预测该指令方向为 需要跳转

如果预测出错，则反向更改当前状态：从 强需要跳转 要出错连续2次才能变为变为 弱不需要跳转，因此具有一定的切换缓冲，其在复杂程序流中预测精度一般比简单的一比特饱和计数器更高

但是使用该方案可能会导致**别名重合**：使用多个两比特饱和计数器负责不同分支指令的预测，会导致大量空间占用，所以只能采用有限个计数器组成计数器表格，但表项数目有限但指令众多，所以很多不同的分支会不可避免地指向相同的表项

解决这个问题一般采用**动态分支预测算法**：采用不同的表格组织方式（控制表格大小）和索引方式（控制别名重合问题）来提高预测精准率，常见算法如下：

1) 一级预测器

将有限个两比特饱和计数器组织成**一维表格**，称为**预测器表格**。直接使用PC值的一部分进行索引

“一级预测器”指的是其索引仅仅采用指令本身的PC值

优点：简单易行

缺点：索引机制过于简单导致预测精度不高

2) 两级预测器

又称为**相关预测器**

对于每条分支，将有限个两比特饱和计数器组织成PHT（Pattern History Table），使用该分支跳转的历史作为PHT的索引

只需要n个bit就能索引2^n^个表项

分支历史又可以分为局部历史（每个分支指令自己的跳转历史）和全局历史（所有分支指令的跳转历史）

**局部分支预测器**采用分立的局部历史缓存，每个缓存有自己对应的PHT，对于每条分支指令，会先索引其对应的局部历史缓存，再使用局部历史缓存中的历史值所引导对应的PHT

**全局分支预测器**使用所有分支指令共享的全局历史缓存。这个解决方案节省资源但只有在PHT容量非常大时才能体现出其优势，且PHT容量越大，优势越明显

常见的全局预测算法有：

* Gshare算法：将分支指令PC值的一部分和共享的全局历史缓存进行**异或**，使用运算的结果作为PHT的索引
* Gselect算法：将分支指令PC值的一部分和共享的全局历史缓存进行**拼接**，使用运算的结果作为PHT的索引

3. 预测地址

分支目标地址需要在**执行阶段计算后才能得到分支的目标地址**，这些任务无法在一个周期内完成，在连续取下一条指令前，甚至连译码判断当前指令是否属于分支指令都无法及时地在一个周期内完成，因此为了连续不断地取指，需要预测分支的目标地址，常见技术如下

1) BTB（Branch Target Buffer分支目标缓存）：使用容量有限的**缓存**保存最近执行过的分支指令的PC值及它们的跳转目标地址。对于后续需要取指的每条PC值，将其与BTB中存储的各个PC值进行比较，如果出现匹配则预测这是一条分支指令，使用其对应存储的跳转目标地址作为预测的跳转地址

优点：最简单快捷

缺点：1. BTB容量与时序、面积难以平衡；2. 对于间接跳转/分支指令的预测效果并不理想

2) RAS（Return Address Stack返回堆栈地址）：使用容量有限的**硬件堆栈**（FIFO）来存储函数调用的返回地址

间接分支/跳转指令多用于函数调用/返回，这两者成对出现，因此可以在函数调用时PC+=4或2，将其顺序执行的下一条指令的PC值压入RAS堆栈，等到函数返回时将其弹出，只要程序正常执行，RAS就能提供较高的预测准确率。不过由于RAS深度有限，出现多次函数嵌套则可能堆栈溢出，影响准确率

优点：正常情况下准确率高

缺点：出现函数嵌套时难以处理

3) Indirect BTB（间接BTB）：专门为间接分支/跳转指令设计的BTB，它通过高级的索引方法进行匹配，结合BTB和动态两级预测器的技术

优点：预测成功率很高

缺点：硬件开销非常大

4. 其它扩展技术

## 执行

经典五级流水线结构中，取指-译码-执行分为三个阶段进行，通过译码让CPU获取指令读取/写回的操作数寄存器索引、指令类型、指令操作信息等。目前高性能处理器普遍采用在每个运算单元前配置乱序发射队列的方式，将指令的相关性解除，从发射队列中发射出来时读取通用寄存器组，再送给运算单元进行计算

五级流水线架构中的执行需要译码之后执行，根据指令的具体操作类型将指令分配给不同的运算单元执行，常见的运算单元如下：

* 算术逻辑运算单元（ALU）：负责普通逻辑运算、加减法运算、移位运算等
* 整数乘法单元：主要负责有符号数或无符号整数的乘法
* 整数除法单元：主要负责有符号数或无符号整数的除法
* 浮点运算单元（FPU）：比较复杂，通常会分成多个不同的独立运算单元

对于其他具有特殊指令的处理器核，会相应增加特殊的运算单元（比如可以在处理器旁挂载DSP等硬件加速电路）

### 执行阶段的分支解析

取指阶段的分支预测功能对于带条件的分支指令，由于器条件解析需要进行操作数运算，所以需要在执行阶段进行运算并判断该分支指令是否真的需要跳转，并按照之前规定的分支预测算法进行对比执行，如果预测错误很可能需要进行流水线冲刷、造成性能损失

一般为了减少性能损失，会在比较靠前的流水线位置进行分支解析

### 数据冲突和冒险

流水线冲突包括资源冲突和数据冲突两类，这两种冲突都会导致流水线阻塞。**数据冲突**顾名思义，就是由于数据相关性引起的冲突。**资源冲突**通常发生在指令派遣给不同的执行单元进行执行的过程中，当一个指令被执行时耗费的时钟周期较长，此后又有其他指令被派发给同一个硬件模块进行处理的情况下便会出现资源冲突的情况——后续的指令需要等待前一个指令完成操作后将硬件模块释放出来后才能得到执行。

## 中断和异常

一般来说由处理器内部的事件或程序执行中的事件引起的程序跳转称为异常；一般的由处理器外部因素引起的程序跳转称为中断

广义上来说中断和异常都被处理器视为**异常**，一般将其分为**同步异常**和**异步异常**

### 同步异常和异步异常

**同步异常**：由于执行程序指令流或者试图执行程序指令流而造成的异常

表现：CPU外部环境一定，多次执行时每次能够精确复现

常见的同步异常包括但不限于：

* 取指令访问到非法的地址区间
* 读写数据访问地址属性出错
* 取指令地址非对齐错误
* 非法指令错误
* 执行调试断点指令

**异步异常**：产生原因不能被精确定位于某条指令的异常

表现：CPU外部环境一定，但是每次发生异常的指令PC都可能会不一样

最常见的异步异常就是*外部中断*。外部中断的发生和中断请求到达时处理器执行的指令都是不确定的，这就导致很难出现反复执行同一条指令时恰好发生外部中断。==外部中断也因此常常被直接用“异步异常中断”指代==

根据处理器响应异常后的状态，可以分为精确异步异常和非精确异步异常

响应异常后处理器状态能精确反映为某一条指令的边界的情况称为**精确异步异常**

> 外部中断狭义来讲就是一种精确异步异常：执行完以后还会返回到原来断开的指令处继续执行

响应异常后处理器状态不能精确反映为某一条指令的边界的情况称为**非精确异步异常**

* 读写存储器出错是一种最常见的非精确异步异常

    访问存储器时处理器还会接着执行指令，如果在此期间出现了访问错误进而触发异常，处理器会在处理到之后的某条指令时进入异常服务程序，难以预测当前执行到了哪个指令

    写入缓存行时，也可能发生类似的错误，具体的原理与访问情况类似